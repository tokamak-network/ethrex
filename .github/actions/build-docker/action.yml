name: Build Docker
description: Builds the Ethrex docker image

inputs:
  username:
    description: "Username for ghcr.io registry login"
    required: false
  password:
    description: "Password or token for ghcr.io registry login"
    required: false
  dockerhub_username:
    description: "Username for DockerHub login (for rate limiting)"
    required: false
  dockerhub_password:
    description: "Password or token for DockerHub login"
    required: false
  registry:
    description: "Docker registry to push the image to (if pushing)"
    required: false
    default: ghcr.io
  tags:
    description: "Comma-separated list of tags to apply to the built image"
    required: false
    default: "ethrex:ci"
  push:
    description: "Whether to push the built image to the registry"
    required: false
    default: "false"
  artifact_path:
    description: "The name of the artifact that is going to be pushed"
    required: false
    default: "ethrex_image.tar"
  build_args:
    description: "The arguments that are sent to the dockerfile to built. Format ARG=value"
    required: false
    default: ""
  platforms:
    description: "Comma-separated list of platforms to build for"
    required: false
    default: "linux/amd64"
  variant:
    description: "Build variant for cache separation (e.g., l1, l2, tokamak)"
    required: false
    default: "l1"
  cache_write:
    description: "Whether to write cache to GHCR registry (set to false for fork PRs)"
    required: false
    default: "true"

outputs:
  artifact_path:
    description: "The path of the image tar inside the action runner"
    value: ${{ steps.vars.outputs.artifact_path }}

runs:
  using: "composite"
  steps:
    - id: vars
      shell: bash
      run: |
        echo "artifact_path=/tmp/${{ inputs.artifact_path }}" >> $GITHUB_OUTPUT

    - id: cache-config
      shell: bash
      run: |
        # Sanitize platform for use in image tags (replace / with -)
        PLATFORM_SAFE=$(echo "${{ inputs.platforms }}" | tr '/' '-')
        echo "platform_safe=$PLATFORM_SAFE" >> $GITHUB_OUTPUT

        # Determine cache scope based on GitHub context
        # - PRs: use pr-<number> for isolation between PRs
        # - Main branch: use 'main'
        # - Tags/releases: use 'main' (read from main's cache)
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          CACHE_SCOPE="pr-${{ github.event.pull_request.number }}"
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          CACHE_SCOPE="main"
        else
          # For tags and other refs, use main's cache
          CACHE_SCOPE="main"
        fi
        echo "cache_scope=$CACHE_SCOPE" >> $GITHUB_OUTPUT

        # Build cache tag components
        VARIANT="${{ inputs.variant }}"
        echo "Cache scope: $CACHE_SCOPE, variant: $VARIANT, platform: $PLATFORM_SAFE"

    - name: Login to DockerHub (for rate limiting)
      if: inputs.dockerhub_username != '' && inputs.dockerhub_password != ''
      uses: docker/login-action@v3
      with:
        username: ${{ inputs.dockerhub_username }}
        password: ${{ inputs.dockerhub_password }}

    - name: Login to ghcr.io (for cache)
      if: inputs.username != '' && inputs.password != '' && inputs.cache_write == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ inputs.username }}
        password: ${{ inputs.password }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - id: build-image
      name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: .
        file: ./Dockerfile
        push: ${{ inputs.push }}
        tags: ${{ inputs.tags }}
        outputs: ${{ inputs.push == 'false' && format('type=docker,dest={0}', steps.vars.outputs.artifact_path) || '' }}
        cache-from: |
          type=registry,ref=${{ inputs.registry }}/${{ github.repository }}:cache-${{ steps.cache-config.outputs.cache_scope }}-${{ inputs.variant }}-${{ steps.cache-config.outputs.platform_safe }}
          type=registry,ref=${{ inputs.registry }}/${{ github.repository }}:cache-main-${{ inputs.variant }}-${{ steps.cache-config.outputs.platform_safe }}
        cache-to: ${{ inputs.cache_write == 'true' && format('type=registry,ref={0}/{1}:cache-{2}-{3}-{4},mode=max', inputs.registry, github.repository, steps.cache-config.outputs.cache_scope, inputs.variant, steps.cache-config.outputs.platform_safe) || format('type=gha,mode=max,scope={0}-{1}-{2}', steps.cache-config.outputs.cache_scope, inputs.variant, steps.cache-config.outputs.platform_safe) }}
        build-args: ${{ inputs.build_args }}
        platforms: ${{ inputs.platforms }}

    # Since we're exporting the image as a tar, we need to load it manually as well
    - name: Load image locally
      shell: bash
      if: inputs.push == 'false'
      run: |
        docker load -i ${{ steps.vars.outputs.artifact_path }}
