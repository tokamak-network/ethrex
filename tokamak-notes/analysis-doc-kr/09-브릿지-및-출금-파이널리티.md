# 09. L1-L2 브릿지 메커니즘 및 출금 파이널리티

> 입금(L1->L2), 출금(L2->L1) 흐름과 출금 파이널리티 조건 분석

---

## 1. 입금 흐름 (L1 -> L2)

### 1.1 전체 입금 흐름도

```
┌─────────────┐    deposit()     ┌──────────────┐   PrivilegedTxSent    ┌───────────┐
│  사용자 (L1) │ ──────────────► │ CommonBridge │ ──── 이벤트 발행 ────► │ L1Watcher │
│             │    ETH 전송      │    (L1)      │                       │ (시퀀서)   │
└─────────────┘                  └──────────────┘                       └─────┬─────┘
                                                                              │
                                        ┌─────────────────────────────────────┘
                                        │ PrivilegedL2Transaction 생성
                                        v
                                 ┌──────────────┐   mintETH()    ┌─────────────┐
                                 │ L2 멤풀에     │ ────────────► │CommonBridgeL2│
                                 │ 특권 TX 추가  │   블록 포함시   │    (L2)      │
                                 └──────────────┘               └──────────────┘
                                                                       │
                                                                       v
                                                                ┌─────────────┐
                                                                │ 사용자 (L2)  │
                                                                │ ETH 수신    │
                                                                └─────────────┘
```

### 1.2 L1 CommonBridge 입금 처리

**파일**: `crates/l2/contracts/src/l1/CommonBridge.sol`

#### ETH 입금

```solidity
// CommonBridge.sol:273-292
function deposit(address l2Recipient) public payable override nonReentrant whenNotPaused {
    deposits[ETH_TOKEN][ETH_TOKEN] += msg.value;
    _sendPrivilegedTransaction(
        SendValues({
            to: L2_BRIDGE_ADDRESS,
            value: msg.value,
            gasLimit: GAS_LIMIT_MINT,
            data: abi.encodeCall(ICommonBridgeL2.mintETH, (l2Recipient))
        }),
        msg.sender
    );
}
```

#### ERC20 입금

```solidity
// CommonBridge.sol:294-315
function depositERC20(
    address tokenL1, address tokenL2,
    address destination, uint256 amount
) public override nonReentrant whenNotPaused {
    deposits[tokenL1][tokenL2] += amount;
    IERC20(tokenL1).safeTransferFrom(msg.sender, address(this), amount);
    _sendPrivilegedTransaction(
        SendValues({
            to: L2_BRIDGE_ADDRESS,
            value: 0,
            gasLimit: GAS_LIMIT_MINT,
            data: abi.encodeCall(ICommonBridgeL2.mintERC20, (tokenL1, tokenL2, destination, amount))
        }),
        msg.sender
    );
}
```

#### 특권 트랜잭션 해시 생성

```solidity
// CommonBridge.sol:234-262
bytes32 l2MintTxHash = keccak256(
    bytes.concat(
        bytes32(CHAIN_ID),
        bytes20(from),
        bytes20(sendValues.to),
        bytes32(transactionId),
        bytes32(sendValues.value),
        bytes32(sendValues.gasLimit),
        bytes32(keccak256(sendValues.data))
    )
);
pendingTxHashes.push(l2MintTxHash);
```

- 트랜잭션 해시가 `pendingTxHashes` 배열에 추가됨
- `PrivilegedTxSent` 이벤트가 발행됨

### 1.3 L1Watcher의 입금 감지

**파일**: `crates/l2/sequencer/l1_watcher.rs`

```
L1Watcher 동작:
1. L1 블록을 주기적으로 폴링 (watch_interval, 기본 12초)
2. CommonBridge의 PrivilegedTxSent 이벤트 필터링
3. 이벤트 데이터를 PrivilegedL2Transaction으로 변환
4. L2 멤풀에 특권 트랜잭션 추가
5. BlockProducer가 다음 블록에 포함
```

### 1.4 L2 CommonBridgeL2의 ETH 수신

**파일**: `crates/l2/contracts/src/l2/CommonBridgeL2.sol`

```solidity
// CommonBridgeL2.sol:45-51
function mintETH(address to) external payable onlySelf {
    (bool success, ) = to.call{value: msg.value}("");
    if (!success) {
        this.withdraw{value: msg.value}(to);  // 실패 시 자동 출금
    }
    emit DepositProcessed(to, msg.value);
}
```

- `onlySelf` 수정자: 브릿지 자체만 호출 가능 (특권 TX를 통해)
- 전송 실패 시 자동으로 출금 처리

### 1.5 주소 앨리어싱 (Address Aliasing)

```solidity
// CommonBridge.sol:205-232
// L1 컨트랙트 주소가 L2에서 동일한 주소의 컨트랙트를 가장하는 것을 방지
// L1 컨트랙트 주소에 ADDRESS_ALIASING 상수를 더해 L2 주소 변환
```

### 1.6 강제 포함 (Forced Inclusion)

```solidity
// CommonBridge.sol:395-430
function hasExpiredPrivilegedTransactions() external view returns (bool) {
    // 각 특권 TX에 마감 기한이 있음 (PRIVILEGED_TX_MAX_WAIT_BEFORE_INCLUSION)
    // 마감 기한이 지나면 체인이 중단됨 → 시퀀서가 검열 불가
}
```

---

## 2. 출금 흐름 (L2 -> L1)

### 2.1 전체 출금 흐름도

```
┌─────────────┐   withdraw()    ┌──────────────┐  sendMessageToL1()  ┌───────────┐
│  사용자 (L2) │ ─────────────► │CommonBridgeL2│ ──────────────────► │ Messenger │
│             │   ETH 전송      │    (L2)      │                     │   (L2)    │
└─────────────┘                 └──────────────┘                     └─────┬─────┘
                                       │                                    │
                                  ETH 소각                          L1Message 이벤트
                                (BURN_ADDRESS)                      (messageId 증가)
                                                                          │
    ┌─────────────────────────────────────────────────────────────────────┘
    v
┌────────────────────────────────────────────────────────────────────────────┐
│                          시퀀서 처리 과정                                    │
│                                                                            │
│  1. BlockProducer: 출금 TX 포함한 블록 생성                                  │
│  2. L1Committer: 블록들을 배치로 묶음                                        │
│     ├─ 출금 메시지 수집 (L1Message 이벤트에서)                                │
│     ├─ 메시지 해시 계산                                                      │
│     ├─ Merkle Tree 구성 → withdrawalsLogsMerkleRoot 생성                    │
│     └─ commitBatch() 호출 → L1에 Merkle Root 게시                           │
│  3. ProofCoordinator → 프루버: 배치 증명 생성                                │
│  4. L1ProofSender: 증명을 L1에 전송                                         │
│  5. OnChainProposer.verifyBatch() 실행                                      │
│     └─ lastVerifiedBatch 업데이트 ← *** 파이널리티 시점 ***                  │
└────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       v
┌─────────────┐  claimWithdrawal()  ┌──────────────┐
│  사용자 (L1) │ ◄─────────────────│ CommonBridge  │
│  ETH 수신   │   Merkle Proof 제출 │    (L1)       │
└─────────────┘                     └──────────────┘
```

### 2.2 L2에서 출금 시작

**파일**: `crates/l2/contracts/src/l2/CommonBridgeL2.sol`

```solidity
// CommonBridgeL2.sol:30-43
function withdraw(address _receiverOnL1) external payable {
    require(msg.value > 0, "Withdrawal amount must be positive");

    // 1. ETH 소각 (BURN_ADDRESS = 0x0)
    (bool success, ) = BURN_ADDRESS.call{value: msg.value}("");
    require(success, "Failed to burn Ether");

    // 2. 출금 이벤트
    emit WithdrawalInitiated(msg.sender, _receiverOnL1, msg.value);

    // 3. Messenger에 L1 메시지 전송
    IMessenger(L1_MESSENGER).sendMessageToL1(
        keccak256(
            abi.encodePacked(ETH_TOKEN, ETH_TOKEN, _receiverOnL1, msg.value)
        )
    );
}
```

### 2.3 Messenger 메시지 기록

**파일**: `crates/l2/contracts/src/l2/Messenger.sol`

```solidity
// Messenger.sol:20-25
// Messenger 주소: 0x0000...FFFE
function sendMessageToL1(bytes32 data) external onlyBridge {
    lastMessageId += 1;
    emit L1Message(msg.sender, data, lastMessageId);
}
```

- 메시지 ID는 순차적으로 증가
- `L1Message(address indexed senderOnL2, bytes32 indexed data, uint256 indexed messageId)` 이벤트 발행

### 2.4 시퀀서의 출금 메시지 수집

**파일**: `crates/l2/common/src/messages.rs`

```rust
// messages.rs:43-50
pub struct L1Message {
    pub from: Address,       // L2 브릿지 주소
    pub data_hash: H256,     // keccak256(tokenL1, tokenL2, receiver, amount)
    pub message_id: U256,    // 순차 메시지 ID
}

// messages.rs:53-60
pub fn encode(&self) -> Vec<u8> {
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&self.from.to_fixed_bytes());       // 20 bytes
    bytes.extend_from_slice(&self.data_hash.0);                // 32 bytes
    bytes.extend_from_slice(&self.message_id.to_big_endian()); // 32 bytes (= 84 bytes)
    bytes
}
```

### 2.5 출금 Merkle Tree 구성

**파일**: `crates/l2/common/src/merkle_tree.rs`

```rust
// merkle_tree.rs:44-54
pub fn compute_merkle_root(hashes: &[H256]) -> H256 {
    let hashes = hashes
        .iter()
        .map(|hash| TreeData(*hash))
        .collect::<Vec<_>>();
    let Some(tree) = MerkleTree::<TreeData>::build(&hashes) else {
        return H256::zero();
    };
    H256::from(tree.root)
}
```

- OpenZeppelin 호환 **교환적(commutative) Keccak256 Merkle Tree** 사용
- 각 출금 메시지를 `keccak256(encoded_message)`로 해시
- 배치 내 모든 출금 메시지의 Merkle Root 계산

### 2.6 L1 커밋 시 Merkle Root 게시

**파일**: `crates/l2/contracts/src/l1/OnChainProposer.sol`

```solidity
// OnChainProposer.sol:306-311
// commitBatch() 내부에서:
if (withdrawalsLogsMerkleRoot != bytes32(0)) {
    ICommonBridge(BRIDGE).publishWithdrawals(
        batchNumber, withdrawalsLogsMerkleRoot
    );
}
```

**파일**: `crates/l2/contracts/src/l1/CommonBridge.sol`

```solidity
// CommonBridge.sol:440-456
function publishWithdrawals(
    uint256 withdrawalLogsBatchNumber,
    bytes32 withdrawalsLogsMerkleRoot
) public onlyOnChainProposer {
    require(
        batchWithdrawalLogsMerkleRoots[withdrawalLogsBatchNumber] == bytes32(0),
        "CommonBridge: withdrawal logs already published"
    );
    batchWithdrawalLogsMerkleRoots[withdrawalLogsBatchNumber] = withdrawalsLogsMerkleRoot;
    emit WithdrawalsPublished(withdrawalLogsBatchNumber, withdrawalsLogsMerkleRoot);
}
```

---

## 3. 출금 파이널리티 조건

### 3.1 파이널리티 = 배치 검증(Verify) 완료

출금 파이널리티의 **핵심 기준**은 `OnChainProposer.lastVerifiedBatch`이다.

```
Commit  ──────►  Prove  ──────►  Verify  ──────►  Claim
(배치 커밋)      (증명 생성)     (증명 검증)       (출금 청구)
                                    │
                            *** 파이널리티 시점 ***
                            lastVerifiedBatch 업데이트
```

### 3.2 검증(Verify) 과정

**파일**: `crates/l2/contracts/src/l1/OnChainProposer.sol`

```solidity
// OnChainProposer.sol:363-480
function verifyBatch(
    uint256 batchNumber,
    bytes memory risc0BlockProof,
    bytes memory sp1ProofBytes,
    bytes memory tdxSignature
) external override onlyOwner whenNotPaused {
    // 1. 배치 번호 순차 확인
    require(batchNumber == lastVerifiedBatch + 1, "...");

    // 2. 배치가 커밋되었는지 확인
    require(batchCommitments[batchNumber].newStateRoot != bytes32(0), "...");

    // 3. 공개 입력(Public Inputs) 구성
    bytes memory publicInputs = _getPublicInputsFromCommitment(batchNumber);

    // 4. ZK 증명 검증 (다중 프루버)
    if (RISC0_VERIFIER != address(0)) {
        // RISC0 증명 검증
    }
    if (SP1_VERIFIER != address(0)) {
        // SP1 증명 검증
    }
    if (TDX_VERIFIER != address(0)) {
        // TDX TEE 증명 검증
    }

    // 5. *** 파이널리티: lastVerifiedBatch 업데이트 ***
    lastVerifiedBatch = batchNumber;  // Line 474
}
```

### 3.3 공개 입력(Public Inputs) 구조

```solidity
// OnChainProposer.sol:648-710
// 고정 크기 (256 bytes):
bytes memory publicInputs = abi.encodePacked(
    previousBatch.newStateRoot,                    // 32B: 이전 상태 루트
    currentBatch.newStateRoot,                     // 32B: 새 상태 루트
    currentBatch.withdrawalsLogsMerkleRoot,        // 32B: 출금 Merkle Root
    currentBatch.processedPrivilegedTransactionsRollingHash, // 32B: 입금 해시
    currentBatch.blobKZGVersionedHash,             // 32B: 블롭 KZG 해시
    currentBatch.lastBlockHash,                    // 32B: 마지막 블록 해시
    bytes32(CHAIN_ID),                             // 32B: 체인 ID
    bytes32(currentBatch.nonPrivilegedTransactions) // 32B: TX 수
);

// 가변 크기:
// + BalanceDiffs (체인별 잔액 변동)
// + L2MessageRollingHashes (크로스체인 메시지)
```

---

## 4. 출금 청구 (Claim Withdrawal)

### 4.1 사용자의 출금 청구

**파일**: `crates/l2/contracts/src/l1/CommonBridge.sol`

```solidity
// CommonBridge.sol:533-549
function claimWithdrawal(
    uint256 claimedAmount,
    uint256 withdrawalBatchNumber,
    uint256 withdrawalMessageId,
    bytes32[] calldata withdrawalProof
) public override whenNotPaused nonReentrant {
    _claimWithdrawal(
        ETH_TOKEN, ETH_TOKEN,
        claimedAmount, withdrawalBatchNumber,
        withdrawalMessageId, withdrawalProof
    );
    // ETH 전송
    (bool success, ) = payable(msg.sender).call{value: claimedAmount}("");
    require(success, "CommonBridge: failed to send ETH");
}
```

### 4.2 검증 로직 (_claimWithdrawal)

```solidity
// CommonBridge.sol:575-615
function _claimWithdrawal(...) private {
    // 검증 1: 충분한 잔액
    require(
        deposits[tokenL1][tokenL2] >= claimedAmount,
        "CommonBridge: not enough balance"
    );

    // 검증 2: 배치가 커밋되었는지 (Merkle Root 존재)
    require(
        batchWithdrawalLogsMerkleRoots[withdrawalBatchNumber] != bytes32(0),
        "CommonBridge: the batch was not committed"
    );

    // ★ 검증 3: 배치가 검증되었는지 (파이널리티 확인)
    require(
        withdrawalBatchNumber <= IOnChainProposer(ON_CHAIN_PROPOSER).lastVerifiedBatch(),
        "CommonBridge: the batch was not verified"
    );

    // 검증 4: 이중 청구 방지
    require(
        claimedWithdrawalIDs[withdrawalMessageId] == false,
        "CommonBridge: already claimed"
    );
    claimedWithdrawalIDs[withdrawalMessageId] = true;

    // 검증 5: Merkle Proof 유효성
    require(
        _verifyMessageProof(msgHash, withdrawalBatchNumber, withdrawalMessageId, withdrawalProof),
        "CommonBridge: Invalid proof"
    );

    // 잔액 차감
    deposits[tokenL1][tokenL2] -= claimedAmount;
}
```

### 4.3 Merkle Proof 검증

```solidity
// CommonBridge.sol:617-632
function _verifyMessageProof(
    bytes32 msgHash,
    uint256 withdrawalBatchNumber,
    uint256 withdrawalMessageId,
    bytes32[] calldata withdrawalProof
) internal view returns (bool) {
    // Leaf 계산
    bytes32 withdrawalLeaf = keccak256(
        abi.encodePacked(L2_BRIDGE_ADDRESS, msgHash, withdrawalMessageId)
    );

    // OpenZeppelin MerkleProof로 검증
    return MerkleProof.verify(
        withdrawalProof,                                          // 증명 경로
        batchWithdrawalLogsMerkleRoots[withdrawalBatchNumber],   // 루트
        withdrawalLeaf                                            // 리프
    );
}
```

---

## 5. 출금 파이널리티 전체 타임라인

```
시간 ──────────────────────────────────────────────────────────────────►

[T0] 사용자 L2에서 출금 시작
     └─ CommonBridgeL2.withdraw() → ETH 소각 + L1Message 이벤트

[T1] 블록에 포함 (BlockProducer, ~5초 후)
     └─ 출금 TX가 L2 블록에 포함

[T2] 배치 커밋 (L1Committer, ~60초 후)
     └─ 블록들이 배치로 묶여 L1에 커밋
     └─ withdrawalsLogsMerkleRoot가 CommonBridge에 게시
     └─ 상태: COMMITTED (아직 출금 불가)

[T3] 증명 생성 (프루버, 수 분~수십 분)
     └─ ProofCoordinator가 프루버에 배치 데이터 전달
     └─ ZK 증명 또는 TEE 증명 생성

[T4] 증명 검증 (L1ProofSender → OnChainProposer)
     └─ verifyBatch() 실행
     └─ lastVerifiedBatch 업데이트
     └─ ★★★ 파이널리티 달성 ★★★

[T5] 사용자 출금 청구 (지연 없이 즉시 가능)
     └─ claimWithdrawal(amount, batchNumber, messageId, proof)
     └─ Merkle Proof 검증 후 ETH/ERC20 전송
```

### 옵티미스틱 롤업과의 차이

| 항목 | Ethrex (ZK Rollup) | 옵티미스틱 롤업 |
|------|--------------------|--------------|
| 파이널리티 조건 | ZK 증명 검증 완료 | 챌린지 기간 만료 (7일) |
| 출금 대기 시간 | 증명 생성 시간 (분~시간) | 7일 |
| 추가 지연 | 없음 (검증 즉시 청구 가능) | 7일 챌린지 기간 필수 |

---

## 6. Timelock 컨트랙트

**파일**: `crates/l2/contracts/src/l1/Timelock.sol`

현재 Timelock은 **직접 통과(passthrough)** 방식으로 동작한다:

```solidity
// Timelock.sol:84 주석
// NOTE: In the future commit and verify will have timelock logic incorporated
// in case there are any zkVM bugs and we want to avoid applying the changes in the L1.
```

- 현재는 지연 없이 즉시 실행
- 향후 zkVM 버그 대응을 위해 지연 로직 추가 예정
- 역할 기반 접근 제어만 수행 (`SEQUENCER` 역할)

---

## 7. Router의 역할

**파일**: `crates/l2/contracts/src/l1/Router.sol`

Router는 **크로스체인 라우팅** 전용이며, 출금 파이널리티와는 직접 관련이 없다:

| 기능 | 설명 |
|------|------|
| `sendETHValue(chainId)` | 체인 간 ETH 전송 라우팅 |
| `injectMessageHashes(chainId, hashes)` | 체인 간 메시지 해시 전달 |
| `registerBridge(chainId, bridge)` | 브릿지 주소 등록 |

- 배치 검증 시 `publishL2Messages()`에서 호출됨
- 멀티체인(Shared Bridge) 환경에서 체인 간 자산/메시지 라우팅

---

## 8. 보안 메커니즘 요약

| 메커니즘 | 설명 | 파일 위치 |
|----------|------|-----------|
| **주소 앨리어싱** | L1 컨트랙트→L2 주소 변조 방지 | CommonBridge.sol:205-232 |
| **강제 포함** | 시퀀서 검열 방지, 마감 기한 초과 시 체인 중단 | CommonBridge.sol:395-430 |
| **토큰 출처 추적** | `deposits[tokenL1][tokenL2]` 매핑으로 실제 입금된 토큰만 출금 가능 | CommonBridge.sol:75-79 |
| **이중 청구 방지** | `claimedWithdrawalIDs[messageId]` 플래그 | CommonBridge.sol:89-94 |
| **Merkle Proof** | 출금 포함 증명 (O(log n) 검증) | CommonBridge.sol:617-632 |
| **ZK 증명 검증** | 상태 전이 유효성 증명 (RISC0/SP1/TDX) | OnChainProposer.sol:422-468 |
| **특권 TX 롤링 해시** | 입금 TX 순서/포함 검증 | OnChainProposer.sol:281-291 |

---

## 9. 코드 참조

| 파일 | 설명 |
|------|------|
| `crates/l2/contracts/src/l1/CommonBridge.sol` | L1 브릿지 (입금, 출금 청구) |
| `crates/l2/contracts/src/l2/CommonBridgeL2.sol` | L2 브릿지 (출금 시작, 입금 수신) |
| `crates/l2/contracts/src/l2/Messenger.sol` | L2 메시지 시스템 |
| `crates/l2/contracts/src/l1/OnChainProposer.sol` | 배치 커밋/검증, 파이널리티 |
| `crates/l2/contracts/src/l1/Router.sol` | 크로스체인 라우팅 |
| `crates/l2/contracts/src/l1/Timelock.sol` | 접근 제어 (향후 지연 로직) |
| `crates/l2/sequencer/l1_watcher.rs` | L1 입금 이벤트 감시 |
| `crates/l2/sequencer/l1_committer.rs` | 배치 커밋 (Merkle Root 게시) |
| `crates/l2/sequencer/l1_proof_sender.rs` | 증명 L1 전송 |
| `crates/l2/common/src/messages.rs` | L1Message 타입, 인코딩 |
| `crates/l2/common/src/merkle_tree.rs` | 출금 Merkle Tree 구성 |
| `crates/l2/common/src/privileged_transactions.rs` | 특권 TX 처리 |

---

*분석일: 2026-02-21*
