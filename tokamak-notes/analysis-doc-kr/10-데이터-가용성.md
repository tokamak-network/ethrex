# 10. L2 데이터 가용성 (Data Availability)

> 롤업 모드와 발리디움 모드에서의 데이터 가용성 메커니즘, EIP-4844 블롭 처리, 상태 재구성 분석

---

## 1. 데이터 가용성 개요

L2 롤업에서 **데이터 가용성(DA)**이란, L2의 트랜잭션/상태 데이터를 L1에 게시하여 누구나 L2 상태를 재구성할 수 있도록 보장하는 것이다.

Ethrex는 **두 가지 DA 모드**를 지원한다:

| 모드 | 데이터 게시 위치 | 트랜잭션 타입 | 보안 수준 |
|------|-----------------|-------------|----------|
| **롤업 (Rollup)** | L1 블롭 (EIP-4844) | EIP-4844 | 완전한 DA |
| **발리디움 (Validium)** | 오프체인 | EIP-1559 | 시퀀서 신뢰 필요 |

---

## 2. 롤업 모드: EIP-4844 블롭 DA

### 2.1 블롭 데이터 구조

**파일**: `crates/l2/sequencer/l1_committer.rs` (Lines 1518-1540)

블롭에 포함되는 데이터:

```
┌──────────────────────────────────────────────┐
│              Blob Data (최대 128KB)           │
├──────────────────────────────────────────────┤
│  [0..8] 블록 개수 (u64, big-endian)           │
├──────────────────────────────────────────────┤
│  Block 1: RLP 인코딩된 전체 블록               │
│  Block 2: RLP 인코딩된 전체 블록               │
│  ...                                         │
│  Block N: RLP 인코딩된 전체 블록               │
├──────────────────────────────────────────────┤
│  FeeConfig 1: 블록 1의 수수료 설정             │
│  FeeConfig 2: 블록 2의 수수료 설정             │
│  ...                                         │
│  FeeConfig N: 블록 N의 수수료 설정             │
└──────────────────────────────────────────────┘
```

```rust
// l1_committer.rs:1518-1524
let mut blob_data = Vec::new();
blob_data.extend(blocks_len.to_be_bytes());  // 8 bytes: 블록 수
for block in blocks {
    blob_data.extend(block.encode_to_vec());  // RLP 인코딩된 전체 블록
}
for fee_config in fee_configs {
    blob_data.extend(fee_config.to_vec());    // 수수료 설정
}
```

**이전 방식(폐기됨)**: State Diffs (수정된 계정/스토리지만 전송) → PR #5135에서 폐기
**현재 방식**: RLP 인코딩된 전체 블록 → 어떤 노드든 처음부터 상태 재구성 가능

### 2.2 블롭 인코딩 (BLS12-381 필드 준수)

**파일**: `crates/common/types/blobs_bundle.rs` (Lines 38-73)

EIP-4844 블롭은 BLS12-381 타원 곡선의 필드 원소 4096개로 구성된다. 각 32바이트 청크가 필드 순서(`0x73eda753...`) 미만이어야 한다.

```
원본 데이터:     [31 bytes] [31 bytes] [31 bytes] ...
                    │           │           │
블롭 인코딩:     [0x00 + 31B] [0x00 + 31B] [0x00 + 31B] ...
                    32B          32B          32B
```

```rust
// blobs_bundle.rs
pub fn blob_from_bytes(bytes: Bytes) -> Result<Blob, BlobsBundleError> {
    // 매 31바이트 앞에 0x00 패딩 삽입
    // → 최상위 바이트가 0x00이므로 항상 필드 순서 미만
}

pub fn bytes_from_blob(blob: Bytes) -> [u8; SAFE_BYTES_PER_BLOB] {
    // 패딩 제거: 각 32바이트 청크에서 첫 31바이트만 추출
}
```

- **블롭 크기**: 128 KB = 4096 필드 원소 x 32 bytes
- **유효 데이터**: ~126.875 KB (31/32 비율)

### 2.3 KZG 커밋먼트 및 증명 생성

**파일**: `crates/common/types/blobs_bundle.rs` (Lines 87-120)

```rust
pub fn create_from_blobs(
    blobs: &Vec<Blob>,
    wrapper_version: Option<u32>,
) -> Result<BlobsBundle, BlobsBundleError> {
    for blob in blobs {
        if wrapper_version == Some(1) {  // Osaka 포크 이후
            let (commitment, cell_proofs) =
                blob_to_commitment_and_cell_proofs(blob)?;
            // 블롭당 여러 개의 Cell 증명
        } else {  // Prague 이전
            let (commitment, proof) =
                blob_to_kzg_commitment_and_proof(blob)?;
            // 블롭당 단일 KZG 증명
        }
    }
}
```

#### Versioned Hash 생성

```rust
fn kzg_commitment_to_versioned_hash(data: &Commitment) -> H256 {
    let mut versioned_hash = keccak(data);
    versioned_hash[0] = VERSIONED_HASH_VERSION_KZG;  // 0x01
    versioned_hash
}
```

- KZG 커밋먼트를 keccak256 해시 → 첫 바이트를 `0x01`로 교체
- 이 해시가 L1 컨트랙트에 저장되어 블롭 존재를 검증

### 2.4 L1 컨트랙트의 블롭 검증

**파일**: `crates/l2/contracts/src/l1/OnChainProposer.sol` (Lines 313-325)

```solidity
// commitBatch() 내부
bytes32 blobVersionedHash = blobhash(0);  // EVM 옵코드: 첫 번째 블롭의 해시

if (VALIDIUM) {
    require(blobVersionedHash == 0, "006");   // 발리디움: 블롭 없어야 함
} else {
    require(blobVersionedHash != 0, "007");   // 롤업: 블롭 있어야 함
}
```

- `blobhash(0)` EVM 옵코드로 트랜잭션에 포함된 블롭의 versioned hash를 조회
- 롤업 모드에서는 블롭이 반드시 존재해야 하고, 발리디움에서는 없어야 함

---

## 3. 발리디움 모드: 오프체인 DA

### 3.1 발리디움 모드 동작

**파일**: `crates/l2/sequencer/l1_committer.rs`

```rust
// Lines 875-893 (배치 생성)
if self.validium {
    BlobsBundle::default()  // 빈 블롭 번들
} else {
    generate_blobs_bundle(blocks, fee_configs, fork)?  // 실제 블롭
}

// Lines 1320-1337 (커밋 전송)
if !self.validium {
    // 롤업: EIP-4844 트랜잭션 (블롭 포함)
    build_generic_tx(&self.eth_client, TxType::EIP4844, ...)
} else {
    // 발리디움: EIP-1559 트랜잭션 (블롭 없음)
    build_generic_tx(&self.eth_client, TxType::EIP1559, ...)
}
```

### 3.2 발리디움 vs 롤업 비교

| 항목 | 롤업 모드 | 발리디움 모드 |
|------|----------|-------------|
| **블롭 생성** | RLP 블록 → 블롭 인코딩 | `BlobsBundle::default()` (빈 값) |
| **TX 타입** | EIP-4844 (Type 3) | EIP-1559 (Type 2) |
| **블롭 가스비** | 필요 (동적 가격) | 불필요 |
| **L1 가스비** | 높음 (블롭 비용) | 낮음 (calldata만) |
| **프루버 입력** | `blob_commitment` = 실제 값 | `[0; 48]` (제로) |
| **컨트랙트 검증** | `blobhash(0) != 0` | `blobhash(0) == 0` |
| **데이터 복구** | L1에서 완전 복구 가능 | 시퀀서에 의존 |
| **보안 모델** | L1 보안 수준 | 시퀀서 신뢰 필요 |

### 3.3 프루버 입력 차이

```rust
// l1_committer.rs:1061-1103
let (blob_commitment, blob_proof) = if self.validium {
    ([0; 48], [0; 48])  // 발리디움: 제로 값
} else {
    let commitment = commitments.last().cloned()?;      // 48 bytes
    let proof = if l1_fork < Fork::Osaka {
        proofs.first().cloned()?                         // 단일 증명
    } else {
        BlobsBundle::create_from_blobs(blobs, Some(0))?  // Osaka: 표준 증명
            .proofs.first().cloned()?
    };
    (commitment, proof)
};
```

---

## 4. 커밋 트랜잭션에 포함되는 데이터

### 4.1 Calldata 구조 (commitBatch)

L1에 제출되는 커밋 TX의 calldata:

```
commitBatch(
    uint256 batchNumber,                              // 배치 번호
    bytes32 newStateRoot,                             // 최종 상태 루트
    bytes32 withdrawalsLogsMerkleRoot,                // 출금 Merkle 루트
    bytes32 processedPrivilegedTransactionsRollingHash, // 입금 롤링 해시
    bytes32 lastBlockHash,                            // 마지막 블록 해시
    uint256 nonPrivilegedTransactions,                // TX 수
    bytes32 commitHash,                               // 프루버 git 해시
    BalanceDiff[] balanceDiffs,                        // 잔액 변동
    L2MessageRollingHash[] l2MessageRollingHashes     // L2 메시지 해시
)
```

### 4.2 BatchCommitmentInfo 구조

**파일**: `crates/l2/contracts/src/l1/OnChainProposer.sol` (Lines 25-44)

```solidity
struct BatchCommitmentInfo {
    bytes32 newStateRoot;                              // 최종 상태 루트
    bytes32 blobKZGVersionedHash;                      // EIP-4844 블롭 참조
    bytes32 processedPrivilegedTransactionsRollingHash; // 입금 추적
    bytes32 withdrawalsLogsMerkleRoot;                 // 출금 증명 루트
    bytes32 lastBlockHash;                             // 마지막 L2 블록 해시
    uint256 nonPrivilegedTransactions;                 // 일반 TX 수
    BalanceDiff[] balanceDiffs;                        // 크로스체인 잔액 변동
    bytes32 commitHash;                                // 프루버 버전 해시
    L2MessageRollingHash[] l2InMessageRollingHashes;   // L2->L2 메시지
}
```

---

## 5. 상태 재구성 (State Reconstruction)

### 5.1 블롭에서 블록 복원

**파일**: `crates/l2/based/block_fetcher.rs` (Lines 395-457)

Based 모드의 BlockFetcher는 L1 커밋 TX에서 L2 블록을 복원한다:

```rust
fn decode_batch_from_calldata(calldata: &[u8]) -> Result<Vec<Block>, BlockFetcherError> {
    // calldata 구조:
    // 0..4:     함수 선택자 (4 bytes)
    // 4..36:    batch number
    // 36..68:   new state root
    // 68..100:  blob KZG versioned hash
    // ...
    // 196..228: 블록 배열 길이
    // 228+:     블록 데이터 (ABI 인코딩된 RLP 블록 배열)

    let batch_length_in_blocks = U256::from_big_endian(
        calldata.get(196..228)?
    ).as_usize();

    for block_i in 0..batch_length_in_blocks {
        let block = Block::decode(block_data)?;
        batch.push(block);
    }
    Ok(batch)
}
```

### 5.2 상태 복구 흐름

**파일**: `crates/l2/utils/state_reconstruct.rs`

```rust
pub async fn get_batch(
    store: &Store,
    batch: &[Block],
    batch_number: U256,
    commit_tx: Option<H256>,
    blobs_bundle: BlobsBundle,
    chain_id: u64,
) -> Result<Batch, UtilsError> {
    // 1. 입금 메시지 추출
    let l1_in_messages = batch.iter()
        .flat_map(|block| get_block_l1_in_messages(&block.body.transactions, chain_id))
        .collect();

    // 2. 출금 메시지 추출
    let l2_messages = /* receipts에서 L1Message 이벤트 추출 */;

    // 3. 잔액 변동 계산
    let balance_diffs = get_balance_diffs(&l2_messages);

    // 4. 롤링 해시 계산
    let l1_in_messages_rolling_hash =
        compute_privileged_transactions_hash(l1_in_messages_hashes)?;

    // 5. Batch 객체 재구성
    Ok(Batch { ... })
}
```

### 5.3 재구성 가능한 데이터

```
L1 블롭 데이터에서 복원 가능:
├── 전체 L2 블록 (헤더 + 바디)
│   ├── 모든 트랜잭션
│   ├── 블록 헤더 (stateRoot, receiptsRoot 등)
│   └── 수수료 설정
├── 입금 메시지 (PrivilegedL2Transaction)
├── 출금 메시지 (L1Message)
├── 잔액 변동 (BalanceDiff)
└── 상태 루트 (검증용)
```

---

## 6. 실행 위트니스 (Execution Witness)

### 6.1 목적

실행 위트니스는 **프루버가 전체 상태 없이도 블록을 실행/검증**할 수 있게 해주는 데이터이다.

### 6.2 구조

**파일**: `crates/l2/common/src/prover.rs`

```rust
pub struct ProverInputData {
    pub blocks: Vec<Block>,                    // 실행할 블록들
    pub execution_witness: ExecutionWitness,   // 상태 접근 증명
    pub elasticity_multiplier: u64,            // 수수료 계산용
    pub blob_commitment: Commitment,           // KZG 커밋먼트 (48B)
    pub blob_proof: Proof,                     // KZG 증명 (48B)
    pub fee_configs: Vec<FeeConfig>,           // 블록별 수수료 설정
}
```

### 6.3 Execution Witness 포함 내용

```
ExecutionWitness:
├── 접근된 계정 상태 (balance, nonce, code)
├── 접근된 스토리지 슬롯 값
├── Merkle Patricia Trie 증명
│   ├── 계정 존재 증명 (inclusion proof)
│   ├── 계정 부재 증명 (exclusion proof)
│   └── 스토리지 증명
└── 이전 상태 루트 → 새 상태 루트 검증
```

- 블록 실행 중 접근/수정된 값만 포함 (전체 상태 불필요)
- MPT 증명으로 초기 상태 루트와의 일관성 검증

---

## 7. KZG 증명 검증 흐름

```
┌──────────────┐    blob_from_bytes()    ┌──────────────┐
│  L2 블록 데이터│ ────────────────────► │  EIP-4844    │
│  (RLP 인코딩)  │                       │  Blob (128KB)│
└──────────────┘                        └──────┬───────┘
                                               │
                        blob_to_kzg_commitment_and_proof()
                                               │
                    ┌──────────────────────────┼──────────────────┐
                    v                          v                  v
            ┌──────────────┐          ┌──────────────┐   ┌──────────────┐
            │  Commitment  │          │   Proof      │   │ Versioned    │
            │  (48 bytes)  │          │  (48 bytes)  │   │ Hash (32B)   │
            └──────┬───────┘          └──────┬───────┘   └──────┬───────┘
                   │                         │                   │
                   │         L1 EIP-4844 TX에 포함               │
                   │                         │                   │
                   v                         v                   v
            ┌─────────────────────────────────────────────────────────┐
            │                  L1 블록에 포함                          │
            │  - 블롭은 L1 합의 레이어에 ~18일간 보관                    │
            │  - Versioned Hash는 실행 레이어에 영구 저장               │
            │  - blobhash(0) 옵코드로 조회 가능                        │
            └─────────────────────────────────────────────────────────┘
                                               │
                                               v
            ┌─────────────────────────────────────────────────────────┐
            │            프루버 검증 (ZK 회로 내부)                      │
            │  1. 블롭 데이터 재구성                                    │
            │  2. KZG 커밋먼트 검증 (commitment == commit(blob))       │
            │  3. 블록 실행 + 상태 전이 검증                            │
            │  4. 공개 입력에 versioned hash 포함                      │
            └─────────────────────────────────────────────────────────┘
```

---

## 8. 포크별 KZG 처리 차이

| 포크 | KZG 방식 | 증명 구조 |
|------|----------|----------|
| **Prague 이전** | Standard KZG | 블롭당 1개 증명 |
| **Osaka 이후** | Cell KZG (PeerDAS) | 블롭당 다수 Cell 증명 |

```rust
// blobs_bundle.rs
fn verify_kzg_proofs(&self) -> Result<(), BlobsBundleError> {
    if self.version == Some(1) {
        // Osaka+: Cell KZG 증명 검증
        ethrex_crypto::kzg::verify_cell_kzg_proof_batch(...)
    } else {
        // Pre-Osaka: 표준 KZG 증명 검증
        ethrex_crypto::kzg::verify_kzg_proof_batch(...)
    }
}
```

---

## 9. DA 비용 최적화

### 9.1 블롭 가스 가격 추정

**파일**: `crates/l2/sequencer/l1_committer.rs` (Lines 1568-1614)

```rust
// 블롭 가스 가격 동적 추정
// EIP-4844의 fake_exponential 함수 사용
// MIN_BASE_FEE_PER_BLOB_GAS와 BLOB_BASE_FEE_UPDATE_FRACTION 기반
```

### 9.2 비용 비교

| DA 방식 | 가스 비용 | 데이터 크기 |
|---------|----------|------------|
| Calldata | ~16 gas/byte | 제한 없음 |
| EIP-4844 Blob | ~1 gas/byte (블롭 가스) | 128 KB/블롭 |
| 발리디움 | 0 (오프체인) | 무제한 |

블롭을 사용하면 calldata 대비 **약 16배 저렴**하게 DA를 달성할 수 있다.

---

## 10. 데이터 가용성 보장 정리

```
┌─────────────────────────────────────────────────────────────────┐
│                    롤업 모드 (기본)                               │
│                                                                 │
│  L2 블록 → RLP 인코딩 → 블롭 인코딩 → EIP-4844 TX → L1 게시     │
│                                                                 │
│  보장:                                                           │
│  ├── L1에 블롭 데이터 존재 (~18일 보관)                            │
│  ├── KZG 커밋먼트로 데이터 무결성 검증                              │
│  ├── blobhash() 옵코드로 블롭 존재 확인                           │
│  ├── 프루버가 블롭 데이터로 상태 전이 검증                          │
│  └── 누구나 L1에서 L2 상태를 완전 재구성 가능                      │
│                                                                 │
│  시퀀서 장애 시: L1 데이터로 독립적 복구 가능                       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    발리디움 모드                                  │
│                                                                 │
│  L2 블록 → 오프체인 저장 → 메타데이터만 L1 게시                    │
│                                                                 │
│  보장:                                                           │
│  ├── 상태 루트와 Merkle Root만 L1에 기록                          │
│  ├── ZK 증명으로 상태 전이 유효성은 검증됨                          │
│  ├── 블롭 데이터는 L1에 없음                                      │
│  └── 시퀀서가 데이터를 보유/제공해야 함                             │
│                                                                 │
│  시퀀서 장애 시: 데이터 손실 위험 (시퀀서 신뢰 필요)                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 11. 코드 참조

| 파일 | 설명 |
|------|------|
| `crates/l2/sequencer/l1_committer.rs` | 배치 커밋, 블롭 생성, DA 모드 분기 |
| `crates/common/types/blobs_bundle.rs` | 블롭 인코딩/디코딩, KZG 처리 |
| `crates/common/crypto/kzg.rs` | KZG 커밋먼트/증명 생성 및 검증 |
| `crates/l2/contracts/src/l1/OnChainProposer.sol` | L1 컨트랙트 블롭 검증 |
| `crates/l2/based/block_fetcher.rs` | L1에서 L2 블록 복원 |
| `crates/l2/utils/state_reconstruct.rs` | 상태 재구성 유틸리티 |
| `crates/l2/common/src/prover.rs` | ProverInputData (실행 위트니스 포함) |
| `docs/l2/fundamentals/data_availability.md` | DA 설계 문서 |
| `docs/l2/fundamentals/state_diffs.md` | State Diffs (폐기됨) 문서 |
| `docs/l2/fundamentals/execution_witness.md` | 실행 위트니스 문서 |

---

*분석일: 2026-02-21*
