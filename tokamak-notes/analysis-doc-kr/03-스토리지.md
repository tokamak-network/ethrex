# Ethrex 프로젝트 분석 - 스토리지 레이어

## 1. 스토리지 아키텍처 개요

```
┌─────────────────────────────────┐
│        Store (고수준 API)        │
│  (블록, 상태, 영수증 API)        │
└────────────┬────────────────────┘
             │
    ┌────────┴────────┐
    v                 v
┌────────────┐   ┌───────────┐
│  InMemory  │   │  RocksDB  │
│  (테스트용) │   │ (프로덕션) │
└────────────┘   └───────────┘
     │                 │
     └────────┬────────┘
              v
    ┌──────────────────┐
    │  TrieLayerCache  │
    │  (최근 블록 캐시) │
    └──────────────────┘
```

**위치**: `crates/storage/`

## 2. 스토리지 백엔드 인터페이스

### 2.1 핵심 트레이트

```rust
// 스토리지 백엔드 (읽기/쓰기 분리)
trait StorageBackend: Debug + Send + Sync {
    fn clear_table(&self, table: &'static str) -> Result<()>;
    fn begin_read(&self) -> Result<Arc<dyn StorageReadView>>;
    fn begin_write(&self) -> Result<Box<dyn StorageWriteBatch>>;
    fn begin_locked(&self, table_name: &'static str) -> Result<Box<dyn StorageLockedView>>;
    fn create_checkpoint(&self, path: &Path) -> Result<()>;
}

// 읽기 뷰 (스냅샷 격리)
trait StorageReadView: Send + Sync {
    fn get(&self, table: &'static str, key: &[u8]) -> Result<Option<Vec<u8>>>;
    fn prefix_iterator(&self, table: &'static str, prefix: &[u8])
        -> Result<Box<dyn Iterator<Item = PrefixResult>>>;
}

// 쓰기 배치 (원자적 커밋)
trait StorageWriteBatch: Send {
    fn put(&mut self, table: &'static str, key: &[u8], value: &[u8]) -> Result<()>;
    fn put_batch(&mut self, table: &'static str, batch: Vec<(Vec<u8>, Vec<u8>)>) -> Result<()>;
    fn delete(&mut self, table: &'static str, key: &[u8]) -> Result<()>;
    fn commit(&mut self) -> Result<()>;
}
```

## 3. 스토리지 테이블 (19개 컬럼 패밀리)

### 3.1 블록 데이터 테이블

| 테이블 | 키 | 값 | 설명 |
|--------|----|----|------|
| `CANONICAL_BLOCK_HASHES` | 블록 번호 | 블록 해시 | 캐노니컬 체인 매핑 |
| `BLOCK_NUMBERS` | 블록 해시 | 블록 번호 | 역방향 매핑 |
| `HEADERS` | 블록 해시 | BlockHeader (RLP) | 블록 헤더 |
| `BODIES` | 블록 해시 | BlockBody (RLP) | 블록 바디 (트랜잭션) |
| `FULLSYNC_HEADERS` | 블록 번호 | BlockHeader (RLP) | 풀 싱크용 헤더 |
| `RECEIPTS` | (블록 해시, 인덱스) | Receipt | 트랜잭션 영수증 |
| `TRANSACTION_LOCATIONS` | 트랜잭션 해시 | (번호, 해시, 인덱스) | 트랜잭션 위치 |

### 3.2 상태 및 컨트랙트 테이블

| 테이블 | 키 | 값 | 설명 |
|--------|----|----|------|
| `ACCOUNT_CODES` | 코드 해시 | 바이트코드 | 컨트랙트 코드 |
| `ACCOUNT_CODE_METADATA` | 코드 해시 | 코드 길이 | 코드 메타데이터 |
| `ACCOUNT_TRIE_NODES` | 노드 해시 | 노드 데이터 | 계정 트라이 노드 |
| `STORAGE_TRIE_NODES` | 노드 해시 | 노드 데이터 | 스토리지 트라이 노드 |
| `ACCOUNT_FLATKEYVALUE` | 니블 경로 | 노드 데이터 | 계정 플랫 키-값 |
| `STORAGE_FLATKEYVALUE` | 니블 경로 | 노드 데이터 | 스토리지 플랫 키-값 |

### 3.3 메타데이터 및 동기화 테이블

| 테이블 | 키 | 값 | 설명 |
|--------|----|----|------|
| `CHAIN_DATA` | ChainDataIndex | ChainConfig (JSON) | 체인 설정 |
| `SNAP_STATE` | SnapStateIndex | 체크포인트 해시 | 스냅 싱크 상태 |
| `PENDING_BLOCKS` | 블록 해시 | Block (RLP) | 대기 중인 블록 |
| `INVALID_CHAINS` | 잘못된 블록 | 최종 유효 블록 | 무효 체인 추적 |
| `MISC_VALUES` | 메타데이터 키 | 메타데이터 값 | 기타 메타데이터 |
| `EXECUTION_WITNESSES` | (번호, 해시) | 실행 증거 | 실행 위트니스 |

## 4. RocksDB 백엔드

### 4.1 최적화 설정

| 설정 | 값 | 설명 |
|------|-----|------|
| max_open_files | -1 (무제한) | 파일 디스크립터 제한 없음 |
| max_background_jobs | 8 | 백그라운드 작업 스레드 |
| max_total_wal_size | 2GB | WAL 최대 크기 |
| target_file_size_base | 512MB | 기본 SST 파일 크기 |
| max_bytes_for_level_base | 2GB | Level 1 최대 크기 |
| level_zero_file_num_compaction_trigger | 2 | Level 0 컴팩션 트리거 |
| enable_pipelined_write | true | 파이프라인 쓰기 |
| total_write_buffer | 1GB | 총 쓰기 버퍼 |
| write_buffer_size | 128MB | 개별 쓰기 버퍼 |
| wal_recovery_mode | PointInTime | 시점 복구 모드 |
| wal_bytes_per_sync | 32MB | WAL 동기화 단위 |

### 4.2 압축 전략

| 테이블 | 압축 | 이유 |
|--------|------|------|
| BLOCK_NUMBERS | LZ4 | 블록 데이터는 압축 효율적 |
| HEADERS | LZ4 | 반복적인 헤더 구조 |
| BODIES | LZ4 | 트랜잭션 데이터 압축 |
| RECEIPTS | LZ4 | 영수증 데이터 압축 |
| TRANSACTION_LOCATIONS | LZ4 | 위치 데이터 압축 |
| FULLSYNC_HEADERS | LZ4 | 헤더 데이터 압축 |
| 트라이 노드 | 없음 | 해시된 데이터는 압축 비효율적 |
| 플랫 키-값 | 없음 | 랜덤 데이터 패턴 |

### 4.3 InMemory 백엔드

테스트 및 개발 모드에서 사용되는 인메모리 스토리지:

```rust
struct InMemoryStore {
    tables: FxHashMap<&'static str, FxHashMap<Vec<u8>, Vec<u8>>>,
}
```

- **용도**: 단위 테스트, 개발 모드 (`--datadir memory`)
- **특징**: 프로세스 종료 시 데이터 소멸
- **장점**: I/O 오버헤드 없이 빠른 테스트

## 5. Merkle Patricia Trie

### 5.1 트라이 구조

```rust
Trie {
    db: Box<dyn TrieDB>,                   // 백엔드 스토리지
    root: NodeRef,                          // 루트 노드
    pending_removal: FxHashSet<Nibbles>,    // 삭제 예정 노드
    dirty: FxHashSet<Nibbles>,              // 수정된 경로
}
```

### 5.2 노드 타입

```
Node
├── Leaf(LeafNode)           // 터미널 노드: 나머지 키 + 값
├── Extension(ExtensionNode) // 압축 노드: 공통 접두사 + 단일 자식
└── Branch(BranchNode)       // 분기 노드: 16개 자식 + 선택적 값
```

#### Leaf 노드
- 남은 전체 경로(니블)와 값을 저장
- 트라이의 끝단 노드

#### Extension 노드
- 공통 경로 접두사를 저장하여 트라이 깊이 축소
- 단일 자식 노드를 가리킴
- 최적화: 긴 공통 경로를 압축

#### Branch 노드
- 16개 자식 (16진수 각 자릿수에 대응)
- 선택적 값 (경로가 이 노드에서 끝나는 경우)

### 5.3 노드 참조

```rust
enum NodeRef {
    Node(Arc<Node>, OnceLock<NodeHash>),  // 인메모리 노드 (해시 지연 계산)
    Hash(NodeHash),                        // 데이터베이스 참조 (해시만 보관)
}
```

- **Node 변형**: 메모리에 로드된 노드, 해시는 필요 시 계산
- **Hash 변형**: 아직 로드되지 않은 노드, 데이터베이스에서 해시로 조회

## 6. 트라이 레이어 캐시 (Layering)

### 6.1 구조

```rust
TrieLayerCache {
    last_id: usize,                              // 단조 증가 레이어 ID
    commit_threshold: usize,                     // DB 커밋까지의 레이어 수
    layers: FxHashMap<H256, Arc<TrieLayer>>,     // 상태 루트 → 레이어 데이터
    bloom: AtomicBloomFilter<FxBuildHasher>,     // 블룸 필터 (빠른 존재 확인)
}

TrieLayer {
    nodes: FxHashMap<Vec<u8>, Vec<u8>>,  // 키 → RLP 인코딩된 노드
    parent: H256,                        // 부모 상태 루트
    id: usize,                           // 레이어 ID
}
```

### 6.2 동작 원리

```
블록 N 실행 → Layer N 생성 (메모리에 변경사항 저장)
    │
블록 N+1 실행 → Layer N+1 생성 (Layer N 위에 덮어씌움)
    │
    ... (commit_threshold까지 반복)
    │
블록 N+128 실행 → 모든 레이어를 RocksDB에 일괄 커밋
```

### 6.3 장점

| 장점 | 설명 |
|------|------|
| **빠른 최근 상태 접근** | 캐시된 블록에 대해 트라이 순회 불필요 |
| **블룸 필터 최적화** | O(1) 거짓 양성 검사로 불필요한 레이어 탐색 방지 |
| **점진적 커밋** | N개 블록마다 DB에 일괄 커밋으로 I/O 최소화 |
| **L2 최적화** | 상태 루트 변경 없는 블록도 처리 가능 |

### 6.4 커밋 전략

- **L1**: ~128 블록마다 (시스템 컨트랙트가 항상 상태 변경)
- **L2**: ~128 블록마다 (정적 상태도 처리)

## 7. FlatKeyValue 최적화

### 7.1 문제

전체 트라이 순회는 상태 접근에 비용이 높다. 특히 스냅 싱크에서 대량의 상태를 빠르게 조회해야 할 때 트라이 경로를 따라가는 것은 비효율적이다.

### 7.2 해결책

```
기존: 루트 → Extension → Branch → ... → Leaf (여러 I/O)
최적화: 니블 경로 → 값 (단일 I/O)
```

- **별도 테이블**: `ACCOUNT_FLATKEYVALUE` 및 `STORAGE_FLATKEYVALUE`
- **니블 기반 키**: O(1) 조회 가능
- **마지막 계산 경로 추적**: 중복 생성 방지
- **효율적 상태 싱크**: 스냅 싱크에서 빠른 범위 조회 지원

## 8. 핵심 데이터 타입

### 8.1 블록 구조

```rust
Block {
    header: BlockHeader,
    body: BlockBody,
}

BlockHeader {
    hash: OnceCell<BlockHash>,              // 캐시된 해시
    parent_hash: H256,                      // 부모 블록 해시
    ommers_hash: H256,                      // 엉클 해시
    coinbase: Address,                      // 마이너/밸리데이터
    state_root: H256,                       // 계정 트라이 루트
    transactions_root: H256,                // 트랜잭션 트라이 루트
    receipts_root: H256,                    // 영수증 트라이 루트
    logs_bloom: Bloom,                      // 로그 블룸 필터
    difficulty: U256,                       // 난이도
    number: BlockNumber,                    // 블록 번호
    gas_limit: u64,                         // 가스 리밋
    gas_used: u64,                          // 사용된 가스
    timestamp: u64,                         // 타임스탬프
    extra_data: Bytes,                      // 추가 데이터
    prev_randao: H256,                      // RANDAO 값 (포스트-머지)
    nonce: u64,                             // 논스
    base_fee_per_gas: Option<u64>,          // 기본 수수료 (EIP-1559)
    withdrawals_root: Option<H256>,         // 출금 루트 (Shanghai)
    blob_gas_used: Option<u64>,             // 블롭 가스 (Cancun)
    excess_blob_gas: Option<u64>,           // 초과 블롭 가스
    parent_beacon_block_root: Option<H256>, // 비콘 루트 (Cancun)
    requests_hash: Option<H256>,            // 요청 해시 (Prague)
    block_access_list_hash: Option<H256>,   // 접근 목록 해시 (Amsterdam)
    slot_number: Option<u64>,               // 슬롯 번호 (Amsterdam)
}

BlockBody {
    transactions: Vec<Transaction>,
    ommers: Vec<BlockHeader>,
    withdrawals: Option<Vec<Withdrawal>>,
}
```

### 8.2 트랜잭션 타입

```rust
enum Transaction {
    LegacyTransaction,           // Pre-EIP-2930: 기본 트랜잭션
    EIP2930Transaction,          // EIP-2930: 접근 목록
    EIP1559Transaction,          // EIP-1559: 동적 수수료
    EIP4844Transaction,          // EIP-4844: 블롭 트랜잭션
    EIP7702Transaction,          // EIP-7702: 계정 위임
    PrivilegedL2Transaction,     // L2 시스템 트랜잭션
    FeeTokenTransaction,         // L2 수수료 토큰 트랜잭션
}
```

**공통 필드**:
- `nonce`: 계정 트랜잭션 카운트
- `gas_limit`: 최대 허용 가스
- `to`: 수신자 (None = 컨트랙트 생성)
- `value`: 전송 ETH/토큰 양
- `data`: 콜데이터/초기화 코드

### 8.3 계정 상태

```rust
AccountState {
    nonce: u64,           // 트랜잭션 카운트
    balance: U256,        // 계정 잔액
    storage_root: H256,   // 스토리지 트라이 루트
    code_hash: H256,      // 컨트랙트 코드 해시
}

Account {
    info: AccountInfo,                  // 기본 정보
    code: Code,                         // 전체 바이트코드
    storage: FxHashMap<H256, U256>,     // 스토리지 슬롯
}

Code {
    hash: H256,               // 코드 해시
    bytecode: Bytes,           // 바이트코드
    jump_targets: Vec<u32>,    // JUMPDEST 위치 (빠른 검증)
}
```

**최적화**:
- `jump_targets`: 사전 계산된 JUMPDEST 위치로 런타임 스캔 회피
- `AccountStateSlimCodec`: 최적화된 인코딩 (빈 스토리지/코드 = 0바이트)

## 9. 스토리지 API (Store)

### 9.1 주요 메서드

#### 블록 관련
```rust
Store {
    // 블록 저장
    fn add_block(&self, block: Block) -> Result<()>;
    fn add_block_header(&self, hash: H256, header: BlockHeader) -> Result<()>;
    fn add_block_body(&self, hash: H256, body: BlockBody) -> Result<()>;

    // 블록 조회
    fn get_block_by_number(&self, number: u64) -> Result<Option<Block>>;
    fn get_block_by_hash(&self, hash: H256) -> Result<Option<Block>>;
    fn get_block_header(&self, hash: H256) -> Result<Option<BlockHeader>>;
    fn get_block_body(&self, hash: H256) -> Result<Option<BlockBody>>;

    // 캐노니컬 체인
    fn set_canonical_block(&self, number: u64, hash: H256) -> Result<()>;
    fn get_canonical_block_hash(&self, number: u64) -> Result<Option<H256>>;
}
```

#### 상태 관련
```rust
Store {
    // 계정 조회
    fn get_account_state(&self, address: Address) -> Result<Option<AccountState>>;
    fn get_storage_at(&self, address: Address, key: H256) -> Result<Option<U256>>;
    fn get_account_code(&self, code_hash: H256) -> Result<Option<Bytes>>;

    // 상태 루트
    fn get_state_root(&self) -> Result<H256>;
    fn compute_state_root(&self) -> Result<H256>;
}
```

#### 트랜잭션 관련
```rust
Store {
    fn get_transaction_by_hash(&self, hash: H256) -> Result<Option<Transaction>>;
    fn get_receipt(&self, hash: H256, index: u64) -> Result<Option<Receipt>>;
    fn get_transaction_location(&self, hash: H256) -> Result<Option<(u64, H256, u64)>>;
}
```

## 10. 데이터 직렬화

### 10.1 RLP (Recursive Length Prefix)

- **블록 헤더/바디**: RLP 인코딩으로 저장
- **트라이 노드**: RLP 인코딩
- **트랜잭션**: 타입별 RLP 인코딩

### 10.2 rkyv (제로카피 직렬화)

- **캐싱**: 고속 직렬화/역직렬화가 필요한 곳에서 사용
- **특징**: 역직렬화 없이 데이터에 직접 접근 가능

### 10.3 JSON

- **체인 설정**: ChainConfig는 JSON으로 저장
- **API 응답**: JSON-RPC 응답

## 11. 동시성 및 안전성

### 11.1 읽기/쓰기 분리

- `begin_read()`: 읽기 전용 스냅샷 뷰 생성
- `begin_write()`: 원자적 쓰기 배치 생성
- `begin_locked()`: 테이블 수준 잠금 뷰

### 11.2 원자적 커밋

```
쓰기 배치 생성
    │
여러 put/delete 연산 수행
    │
commit() → 모든 변경사항을 한 번에 적용
```

### 11.3 체크포인트

```rust
fn create_checkpoint(&self, path: &Path) -> Result<()>;
```

- RocksDB의 하드 링크 기반 체크포인트
- 일관된 스냅샷 생성 (백업, 디버깅 용도)
