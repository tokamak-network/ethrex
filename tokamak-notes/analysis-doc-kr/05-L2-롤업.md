# Ethrex 프로젝트 분석 - L2 ZK-Rollup

## 1. L2 아키텍처 개요

Ethrex L2는 **다중 프루버(Multi-Prover) ZK-Rollup** 플랫폼으로, 다양한 영지식 증명 백엔드를 지원한다.

```
┌──────────────────────────────────────────────────────────┐
│                     L2 시퀀서 (Sequencer)                 │
│                                                          │
│ ┌───────────┐ ┌────────────┐ ┌──────────┐ ┌──────────┐  │
│ │ Block     │ │ L1         │ │ L1       │ │ Proof    │  │
│ │ Producer  │ │ Committer  │ │ Watcher  │ │ Coord.   │  │
│ │(블록 생산)│ │(배치 커밋) │ │(L1 감시) │ │(증명 조정)│  │
│ └─────┬─────┘ └─────┬──────┘ └────┬─────┘ └────┬─────┘  │
│       │             │              │             │        │
│       v             v              v             v        │
│ ┌──────────────────────────────────────────────────────┐  │
│ │              State Updater (상태 업데이터)            │  │
│ └──────────────────────────────────────────────────────┘  │
│                          │                                │
│                          v                                │
│ ┌──────────────────────────────────────────────────────┐  │
│ │          L2 Storage + L1 Storage (스토리지)           │  │
│ └──────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────┘
                           │
                           v
┌──────────────────────────────────────────────────────────┐
│                    이더리움 L1                             │
│                                                          │
│  ┌──────────────┐  ┌──────────────┐  ┌───────────────┐   │
│  │ OnChain      │  │ Common       │  │ Router        │   │
│  │ Proposer     │  │ Bridge       │  │ (라우터)      │   │
│  │ (제안자)     │  │ (브릿지)     │  │               │   │
│  └──────────────┘  └──────────────┘  └───────────────┘   │
└──────────────────────────────────────────────────────────┘
```

**위치**: `crates/l2/`

## 2. 시퀀서 컴포넌트

### 2.1 컴포넌트 목록

| 컴포넌트 | 역할 | 시작 메시지 |
|----------|------|-------------|
| **BlockProducer** | L2 블록 생산 | `InMessage::Produce` |
| **L1Committer** | L1에 배치 커밋 | `InMessage::Commit` |
| **L1Watcher** | L1 입금/메시지 감시 | `InMessage::WatchLogsL1` |
| **L1ProofSender** | L1에 증명 전송 | `InMessage::SendProof` |
| **ProofCoordinator** | 증명 생성 조정 | `InMessage::Listen` |
| **StateUpdater** | L2 상태 동기화 | `InMessage::UpdateState` |

### 2.2 초기 상태

| 모드 | 시작 상태 | 설명 |
|------|-----------|------|
| Aligned | `Sequencing` | 즉시 시퀀싱 시작 |
| Based | `Syncing` | L1에서 상태 가져오기 |
| Standard | `Sequencing` (start_at=0) 또는 `Syncing` | 조건부 |

## 3. 블록 프로듀서 (BlockProducer)

### 3.1 블록 생산 사이클

```
Produce 메시지 수신
    │
    v
대기 중인 트랜잭션 가져오기 (멤풀)
    │
    v
특권 트랜잭션 가져오기 (입금, L2 인메시지)
    │
    v
EVM에서 트랜잭션 실행
    │
    v
L2 아웃메시지 로그 수집
    │
    v
블록을 실행기에 전송
    │
    v
Done 메시지 (다음 사이클 준비)
```

### 3.2 특권 트랜잭션 논스 관리

```rust
privileged_nonces: HashMap<u64, Option<u64>>  // chain_id → nonce
// L1 체인별 순차 논스 할당 보장
```

### 3.3 건강 모니터링

```rust
BlockProducerHealth {
    sequencer_state: String,        // 시퀀서 상태
    block_time_ms: u64,             // 블록 생성 간격
    coinbase_address: Address,      // 코인베이스 주소
    elasticity_multiplier: u64,     // 탄력성 승수
}
```

## 4. L1 커미터 (L1Committer)

### 4.1 배치 커밋 구조

```solidity
function commitBatch(
    uint256 batchNumber,
    bytes32 newStateRoot,
    bytes32 withdrawalsLogsMerkleRoot,
    bytes32 processedPrivilegedTransactionsRollingHash,
    bytes32 lastBlockHash,
    uint256 nonPrivilegedTransactions,
    bytes32 commitHash,
    BalanceDiff[] calldata balanceDiffs,
    L2MessageRollingHash[] calldata l2MessageRollingHashes
)
```

### 4.2 배치 커밋 정보 (BatchCommitmentInfo)

| 필드 | 설명 |
|------|------|
| `newStateRoot` | 배치 실행 후 최종 상태 루트 |
| `blobKZGVersionedHash` | EIP-4844 블롭 해시 (롤업 모드) |
| `processedPrivilegedTransactionsRollingHash` | 2바이트 카운트 + 머클 해시 |
| `withdrawalsLogsMerkleRoot` | 출금 로그 머클 루트 |
| `lastBlockHash` | 배치 내 마지막 L2 블록 해시 |
| `nonPrivilegedTransactions` | 비특권 트랜잭션 수 |
| `balanceDiffs` | 다른 체인으로의 자산 이전 |
| `commitHash` | 검증키 관리용 Git 커밋 해시 |
| `l2InMessageRollingHashes` | 체인별 메시지 롤링 해시 |

### 4.3 배치 제약 조건

- 순차적 배치 번호만 허용 (N+1)
- 블록 가스 리밋 ≤ 배치 가스 리밋
- 이미 커밋된 배치는 재커밋 불가

### 4.4 커미터 상태 머신

```
Stopped → Start(wait_time_ms)
    │
    v
Started → 커밋할 블록 폴링
    │
    v
Commit 또는 Abort
    │
    v
L1에 트랜잭션 전송
    │
    v
확인 대기 → 다음 배치
```

## 5. L1 워처 (L1Watcher)

### 5.1 감시 대상

| 이벤트 | 소스 | 설명 |
|--------|------|------|
| Deposit | CommonBridge | L1→L2 ETH/ERC20 입금 |
| L2Message | Router | 크로스체인 메시지 |
| 특권 트랜잭션 | CommonBridge | L2 시스템 호출 |

### 5.2 동작 흐름

```
L1 블록 스캔
    │
    v
CommonBridge의 Deposit 이벤트 필터링
    │
    v
Router의 L2Message 이벤트 필터링
    │
    v
특권 트랜잭션 생성
    │
    v
대기열에 저장 (pendingTxHashes)
    │
    v
L1 블롭 기본 수수료 주기적 업데이트
```

### 5.3 설정

```rust
L1WatcherConfig {
    max_block_step: U256,           // L1 스캔당 최대 블록 수
    check_interval: u64,            // 스캔 간격 (ms)
    l1_block_delay: u64,            // L1 블록 처리 지연
    l1_blob_base_fee_update_interval: u64, // 블롭 수수료 갱신 간격
    bridge_address: Address,        // 브릿지 컨트랙트 주소
    router_address: Address,        // 라우터 컨트랙트 주소
    l2_rpc_urls: Vec<Url>,          // 공유 브릿지용 L2 RPC
    l2_chain_ids: Vec<u64>,         // 대응하는 체인 ID
}
```

## 6. 증명 조정기 (ProofCoordinator)

### 6.1 지원 프루버 타입

| 프루버 | 설명 |
|--------|------|
| **RISC Zero** | RISC-V 기반 영지식 증명 시스템 |
| **SP1** | Succinct Labs의 최적화된 RISC-V 증명 |
| **Zisk** | Polygon의 ZK VM |
| **OpenVM** | OpenVM 증명 시스템 |
| **Exec** | 직접 실행 (증명 없음, 테스트 모드) |

### 6.2 메시지 흐름

```
프루버 연결 → 작업 요청
    │
    v
코디네이터 응답:
├── Batch(ProverData)    → 배치 데이터 + ProgramInput
├── RetryLater           → 현재 작업 없음
└── ProverTypeNotNeeded  → 이 코디네이터에 불필요
    │
    v
프루버가 증명 생성
    │
    v
프루버가 증명 반환
    │
    v
코디네이터가 증명 저장 → 검증 준비 완료
```

### 6.3 ProverData 구조

```rust
ProverData {
    batch_number: u64,         // 배치 번호
    input: ProgramInput,       // 게스트 프로그램 입력
    format: ProofFormat,       // 인코딩 형식
}
```

## 7. L1 증명 전송기 (L1ProofSender)

### 7.1 검증 과정

```solidity
function verifyBatch(
    uint256 batchNumber,
    bytes memory risc0BlockProof,
    bytes memory sp1ProofBytes,
    bytes memory tdxSignature
)
```

### 7.2 검증 단계

```
1. 커밋된 배치에서 공개 입력 재구성
    │
2. RISC Zero 증명 검증 (필요 시)
    │
3. SP1 증명 검증 (필요 시)
    │
4. TDX 증명 검증 (필요 시)
    │
5. 대기 중인 특권 트랜잭션 제거
    │
6. 대기 중인 L2 메시지 제거
    │
7. L2 메시지 게시 (잔액 차이)
    │
8. 배치를 검증 완료로 표시
```

### 7.3 공개 입력 구조 (256바이트 고정 + 가변)

| 바이트 범위 | 내용 |
|------------|------|
| 0-32 | 초기 상태 루트 (마지막 검증 배치) |
| 32-64 | 최종 상태 루트 (현재 배치) |
| 64-96 | 출금 머클 루트 |
| 96-128 | 처리된 L1 메시지 롤링 해시 |
| 128-160 | 블롭 버전드 해시 |
| 160-192 | 마지막 블록 해시 |
| 192-224 | 체인 ID |
| 224-256 | 비특권 트랜잭션 수 |

**가변 필드**:
- 각 잔액 차이: chain_id(32) + value(32) + 자산별 데이터
- 각 L2 메시지 롤링 해시: chainId(32) + rollingHash(32)

### 7.4 Aligned Layer 지원

- 스마트 컨트랙트 직접 검증 대안
- SP1 증명 집계
- 머클 증명 포함 검증

## 8. Based 시퀀싱 모드

### 8.1 개요

Based 시퀀싱은 L1 시퀀서를 기반으로 하는 모드:

- L1 배치 콜데이터에서 블록 구성
- 로컬 트랜잭션 멤풀 없음
- L1에 커밋된 배치에서 트랜잭션 파생

### 8.2 BlockFetcher 프로세스

```
1. L1에서 새 배치 커밋 폴링
    │
2. OnChainProposer에서 배치 콜데이터 가져오기
    │
3. 콜데이터에서 L2 블록 디코딩
    │
4. 블록 실행으로 상태 재구성
    │
5. L2 데이터베이스에 저장
    │
6. 포크 초이스 업데이트 적용
```

## 9. 스마트 컨트랙트

### 9.1 OnChainProposer (L1)

**배치 관리**:
```solidity
mapping(uint256 => BatchCommitmentInfo) batchCommitments;
uint256 lastVerifiedBatch;
uint256 lastCommittedBatch;
```

**검증키 관리**:
```solidity
mapping(bytes32 commitHash => mapping(uint8 verifierId => bytes32 vk)) verificationKeys;

// 검증자 ID
SP1_VERIFIER_ID = 1
RISC0_VERIFIER_ID = 2
```

**배치 되돌리기** (일시 정지 시):
- 미검증 배치 되돌리기 가능
- lastVerifiedBatch 이후 커밋 정리
- lastCommittedBatch 업데이트

### 9.2 CommonBridge (L1)

#### 입금 관리
```solidity
// ETH 입금
function deposit(address l2Recipient) external payable;

// ERC20 입금
function depositERC20(
    address tokenL1,
    address tokenL2,
    address destination,
    uint256 amount
) external;
```

#### 출금 처리
```solidity
// 검증된 배치의 머클 루트 저장
// 출금 청구
function claimWithdrawal(
    uint256 amount,
    uint256 batchNumber,
    uint256 messageId,
    bytes32[] calldata proof
) external;
```

#### 특권 트랜잭션 (L1→L2)
```solidity
function sendToL2(SendValues calldata values) external;
// 대기열: pendingTxHashes[]
// 포함 기한 추적
```

#### 주소 에일리어싱
- L1 컨트랙트가 L2에서 동일 주소 사칭 방지
- EOA는 정상 처리
- EIP-7702 위임 계정 감지

### 9.3 Router (L1)

크로스체인 메시지 라우팅:
- 체인 간 메시지 전달
- 체인별 대기 메시지 추적
- 버전드 해시 기반 롤링 머클 트리

### 9.4 데이터 구조

```solidity
struct BalanceDiff {
    uint64 chainId;
    uint256 value;
    AssetDiff[] assetDiffs;
    bytes32[] message_hashes;
}

struct AssetDiff {
    address tokenL1;
    address tokenL2;
    address destTokenL2;
    uint256 value;
}

struct L2MessageRollingHash {
    uint64 chainId;
    bytes32 rollingHash;
}
```

## 10. 데이터 가용성

### 10.1 접근 방식

| 방식 | 설명 |
|------|------|
| **초기** | 상태 차이(State Diffs): 변경된 상태만 게시 |
| **현재** | RLP 인코딩된 블록을 블롭(EIP-4844)에 게시 |

### 10.2 현재 방식의 장점

- 트랜잭션과 상태 변경 모두 포함
- KZG 커밋먼트로 블롭 검증
- 더 명시적인 상태 가용성

### 10.3 배치 커밋먼트 내용

| 항목 | 설명 |
|------|------|
| 새 L2 상태 루트 | 배치 실행 후 최종 상태 |
| 마지막 블록 해시 | 배치 내 최종 블록 |
| KZG 버전드 해시 | 블롭 데이터의 KZG 커밋먼트 |
| 특권 트랜잭션 롤링 해시 | 처리된 특권 트랜잭션 |
| 출금 로그 머클 루트 | 출금 데이터의 머클 증명 |

## 11. 증명 시스템 상세

### 11.1 ZK 게스트 프로그램

```
공개 입력 (해시됨):
├── 이전 배치 커밋먼트 (상태 루트)
├── 다음 배치 커밋먼트 (상태 루트)
├── 블롭의 KZG 버전드 해시
├── 처리된 트랜잭션 롤링 해시
└── 출금 로그 머클 루트
                │
                v
    ┌─────────────────────────┐
    │  게스트 프로그램 (zkVM)  │
    │  - 모든 블록 실행        │
    │  - 상태에 대한 머클      │
    │    증명 생성             │
    └────────────┬────────────┘
                 │
                 v
    ┌─────────────────────────┐
    │  영지식 증명 생성        │
    │  (SP1, RISC Zero 등)    │
    └────────────┬────────────┘
                 │
                 v
    ┌─────────────────────────┐
    │   L1 검증자 컨트랙트    │
    │  - 증명 검증            │
    │  - 커밋먼트 확인        │
    │  - 상태 업데이트        │
    └─────────────────────────┘
```

### 11.2 지원 증명 백엔드 비교

| 백엔드 | ISA | 특징 |
|--------|-----|------|
| SP1 | RISC-V | Succinct Labs, 빠른 증명 |
| RISC Zero | RISC-V | 성숙한 생태계 |
| Zisk | 커스텀 | Polygon, 최적화 |
| OpenVM | 커스텀 | OpenVM 프레임워크 |
| TEE | N/A | 하드웨어 신뢰 환경 (TDX) |
| Exec | N/A | 테스트용 직접 실행 |

## 12. 핵심 데이터 흐름

### 12.1 블록 생산 → 커밋 → 검증

```
BlockProducer
  │ L2 블록 생산
  v
L1Committer
  │ 블록을 배치로 묶음
  │ 콜데이터 + 블롭으로 인코딩
  v
submitBatch (L1 트랜잭션)
  │ L1이 검증 및 저장
  v
ProofCoordinator
  │ 작업 폴링
  v
ProverBackend (SP1/RISC0/TDX/Zisk)
  │ 증명 생성
  v
L1ProofSender
  │ verifyBatch() 호출
  v
OnChainProposer
  │ 증명 검증, 출금 게시
  v
배치 검증 완료
```

### 12.2 L1 입금 → L2 실행

```
L1: CommonBridge.deposit() (사용자가 ETH/ERC20 전송)
  │
L1Watcher가 브릿지 이벤트 감시
  │
특권 트랜잭션 생성
  │
CommonBridge.pendingTxHashes에 저장
  │
BlockProducer가 대기 입금 가져오기
  │
L2 민트 트랜잭션 생성
  │
L2 블록에서 실행
  │
잔액 업데이트 이벤트 발행
  │
L1Committer가 배치에 포함
  │
verifyBatch()가 대기열에서 제거
```

### 12.3 L2 출금 → L1 청구

```
L2: 사용자가 출금 트랜잭션 전송
  │
L2 블록에서 실행, 출금 로그 생성
  │
BlockProducer가 출금 로그 수집
  │
L1Committer가 배치에 포함
  │ 출금 머클 루트 계산
  │
L1: commitBatch()에 출금 머클 루트 포함
  │
증명 검증 후 배치 확정
  │
사용자가 claimWithdrawal() 호출
  │ 머클 증명으로 출금 검증
  │
L1에서 ETH/ERC20 전송
```

## 13. L2 스토리지

### 13.1 구조

L2 전용 스토리지 (`crates/l2/storage/`):

| 데이터 | 설명 |
|--------|------|
| 트랜잭션 이력 | L2 트랜잭션 기록 |
| 배치 메타데이터 | 배치 번호, 상태, 커밋 정보 |
| 증명 아티팩트 | 생성된 증명 저장 |
| 시퀀서 상태 | 시퀀서 동기화 상태 |

### 13.2 백엔드

- **InMemory**: 테스트용
- **SQL**: 프로덕션용 (PostgreSQL 등)

## 14. L2 RPC 엔드포인트

`crates/l2/networking/rpc/`에서 L2 전용 JSON-RPC 메서드 제공:

| 모듈 | 설명 |
|------|------|
| `batch` | 배치 상태 조회 |
| `execution_witness` | 실행 위트니스 |
| `fees` | L2 수수료 추정 |
| `messages` | L1-L2 메시지 |
| `transaction` | L2 트랜잭션 |

## 15. 수수료 토큰 시스템

### 15.1 구조

L2에서 ETH 외의 ERC20 토큰으로 수수료 지불 가능:

```
FeeTokenRegistry (0xfffc)    → 수수료 토큰 등록/관리
FeeTokenPricer   (0xfffb)    → 토큰 환율 관리
```

### 15.2 동작

```
1. 수수료 토큰 등록 (FeeTokenRegistry)
2. 토큰 환율 설정 (FeeTokenPricer)
3. 사용자가 FeeTokenTransaction 전송
4. 시퀀서가 토큰 수수료를 ETH 환산으로 계산
5. 트랜잭션 실행 및 수수료 공제
```
