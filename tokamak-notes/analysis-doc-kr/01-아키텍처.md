# Ethrex 프로젝트 분석 - 전체 아키텍처

## 1. 시스템 아키텍처 개요

Ethrex는 이더리움 실행 클라이언트로서, 합의 클라이언트(Consensus Client)와 Engine API를 통해 통신하며 블록 실행, 상태 관리, P2P 네트워킹, RPC 서비스를 제공한다.

```
┌─────────────────────────────────────────────────────────────┐
│                    합의 클라이언트 (Consensus Client)         │
│                 (Lighthouse, Prysm, Teku 등)                 │
│                   Engine API (JWT 인증)                      │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────┴────────────────────────────────────┐
│              ethrex 실행 클라이언트 (Execution Client)        │
│                                                              │
│ ┌──────────┐  ┌───────────┐  ┌────────────────────────┐     │
│ │ JSON-RPC │  │ Engine    │  │   P2P 네트워크          │     │
│ │ 서버     │  │ API       │  │  ┌──────┐  ┌─────────┐ │     │
│ │          │  │           │  │  │DiscV4│  │  RLPx   │ │     │
│ │ eth_*    │  │ fork      │  │  │      │  │ eth/68  │ │     │
│ │ debug_*  │  │ choice    │  │  │      │  │ snap/1  │ │     │
│ │ txpool_* │  │ newPayload│  │  └──────┘  └─────────┘ │     │
│ └──────┬───┘  └─────┬─────┘  └──────────┬─────────────┘     │
│        │            │                    │                   │
│        └────────────┼────────────────────┘                   │
│                     │                                        │
│                     v                                        │
│        ┌─────────────────────────────┐                      │
│        │      블록체인 (Blockchain)   │                      │
│        │ ┌──────┐ ┌──────┐ ┌──────┐  │                      │
│        │ │멤풀  │ │페이로│ │포크  │   │                      │
│        │ │      │ │드빌드│ │초이스│   │                      │
│        │ └──────┘ └──────┘ └──────┘  │                      │
│        └──────────────┬──────────────┘                      │
│                       v                                      │
│        ┌─────────────────────────────┐                      │
│        │   EVM 실행 엔진 (LEVM)      │                      │
│        │ ┌─────────────────────────┐ │                      │
│        │ │ Opcode 핸들러           │ │                      │
│        │ │ 프리컴파일, 가스 미터링 │ │                      │
│        │ └─────────────────────────┘ │                      │
│        └──────────────┬──────────────┘                      │
│                       v                                      │
│        ┌─────────────────────────────┐                      │
│        │      스토리지 레이어         │                      │
│        │ ┌────────────────────────┐  │                      │
│        │ │  RocksDB / InMemory    │  │                      │
│        │ │  State Trie + FlatKV   │  │                      │
│        │ └────────────────────────┘  │                      │
│        └─────────────────────────────┘                      │
└──────────────────────────────────────────────────────────────┘
```

## 2. 진입점 (Entry Point)

### 2.1 메인 바이너리 (`cmd/ethrex/ethrex.rs`)

메인 바이너리는 다음 순서로 초기화된다:

1. **Jemalloc 메모리 할당자 설정** - Linux/macOS에서 성능 최적화
2. **CPU 프로파일링** (선택적) - pprof 기반
3. **시그널 핸들러 등록** - SIGTERM/SIGINT 시 안전한 종료
4. **Rayon 스레드 풀 구성** - 병렬 처리용 글로벌 스레드 풀
5. **L1 초기화** - `init_l1()` 호출로 핵심 컴포넌트 시작
6. **버전 체크** - 주기적으로 최신 릴리스 확인

### 2.2 안전한 종료 (Graceful Shutdown)

```
SIGTERM/SIGINT 수신
    │
    v
1. 피어 테이블을 디스크에 저장
2. 노드 설정 저장
3. CancellationToken으로 모든 작업 취소
4. CPU 프로파일 저장 (활성화된 경우)
5. 안전한 종료
```

### 2.3 CLI 옵션 구조

```
Options {
    // 노드 설정
    network: mainnet | holesky | sepolia | hoodi
    datadir: 데이터베이스 경로 (또는 "memory")
    syncmode: "full" | "snap"

    // RPC 서버
    http_addr/port          → JSON-RPC HTTP 엔드포인트
    ws_addr/port            → WebSocket 엔드포인트
    authrpc_addr/port       → Engine API (JWT 인증)

    // P2P 네트워킹
    p2p_addr/port           → P2P 리스닝 주소
    discovery_port          → 디스커버리 UDP 포트
    bootnodes               → 부트노드 목록
    target_peers            → 목표 피어 수

    // 블록 빌딩
    extra_data              → 블록 추가 데이터
    gas_limit               → 가스 제한
    max_blobs_per_block     → 블록당 최대 블롭 수

    // 로깅
    log_level               → 로그 수준
    metrics_enabled         → Prometheus 메트릭 활성화

    // 기타
    dev: bool               → 개발 모드
}
```

### 2.4 서브커맨드

| 커맨드 | 설명 |
|--------|------|
| `removedb` | 데이터베이스 삭제 |
| `import` | RLP 체인 파일 가져오기 |
| `import-bench` | 성능 측정과 함께 가져오기 |
| `export` | 블록을 RLP 파일로 내보내기 |
| `compute-state-root` | 제네시스 상태 루트 계산 |
| `repl` | JSON-RPC 대화형 콘솔 |
| `l2` | L2 전용 커맨드 |

## 3. 블록 실행 파이프라인

### 3.1 전체 흐름

```
수신된 블록
    │
    ├── 1. 헤더 검증 (Header Validation)
    │   ├── 부모 블록 존재 확인
    │   ├── 타임스탬프 증가 확인
    │   ├── 가스 리밋 유효성
    │   ├── Difficulty / PrevRandao
    │   └── Extra Data 크기 제한
    │
    ├── 2. 바디 검증 (Body Validation)
    │   ├── 트랜잭션 수 < 2^16
    │   ├── 총 데이터 크기 < 2^24
    │   ├── Initcode 크기 검사
    │   ├── 트랜잭션 RLP 유효성
    │   └── 출금 수 < 2^16
    │
    ├── 3. 트랜잭션 실행 (LEVM)
    │   ├── 시스템 연산 (비콘 루트 저장)
    │   ├── 트랜잭션 순차 처리
    │   ├── 출금 처리 (Shanghai+)
    │   ├── 요청 추출 (Prague+)
    │   └── 상태 루트 계산
    │
    └── 4. 상태 루트 검증
        └── 계산된 루트 == 헤더 루트 → 블록 유효
```

### 3.2 트랜잭션 실행 순서

```
각 트랜잭션에 대해:
  1. 서명 및 논스(nonce) 검증
  2. 잔액 충분한지 확인
  3. EVM에서 실행
  4. 상태 변경 적용
  5. 가스 및 수수료 수집
  6. 계정 논스 업데이트
  7. 영수증(Receipt) 기록
```

### 3.3 상태 전이

```
실행 전(Pre-execution)  → 상태 스냅샷 생성
실행 중(During)         → 메모리/스토리지 변경 적용
실행 후(Post-execution) → 트라이 구조에 커밋
블록 완료 후(After)      → 트라이 노드를 영구 스토리지에 저장
```

## 4. 포크 초이스 (Fork Choice)

### 4.1 포크 초이스 상태

```rust
ForkChoiceState {
    head_block_hash: H256,       // 현재 헤드 블록
    safe_block_hash: H256,       // 안전한 블록 (2/3 검증)
    finalized_block_hash: H256,  // 최종 확정 블록
}
```

### 4.2 검증 규칙

1. 헤드 해시는 존재하는 블록이어야 함
2. 순서: `finalized <= safe <= head`
3. 모든 블록이 데이터베이스에 존재해야 함
4. 헤드가 캐노니컬 체인과 연결되어야 함
5. finalized와 safe는 head의 조상이거나 이미 캐노니컬이어야 함

### 4.3 업데이트 과정

```
포크 초이스 업데이트 수신
    │
    v
1. 헤드와 그 조상을 캐노니컬로 설정
2. 블록 번호별 캐노니컬 해시 업데이트
3. 리오그(reorg) 마커 리셋
4. VALID 또는 SYNCING 상태 반환
```

## 5. 멤풀 (Mempool)

### 5.1 구조

```rust
Mempool {
    transaction_pool: HashMap<H256, MempoolTransaction>,     // 해시별 트랜잭션
    blobs_bundle_pool: HashMap<H256, BlobsBundle>,           // 블롭 번들
    txs_by_sender_nonce: BTreeMap<(Address, u64), H256>,     // 발신자+논스별 정렬
    txs_order: VecDeque<H256>,                               // 삽입 순서
    max_mempool_size: usize,                                 // 최대 크기
}
```

### 5.2 주요 연산

| 연산 | 설명 |
|------|------|
| `add_transaction()` | 트랜잭션 삽입 |
| `remove_transaction()` | 해시로 트랜잭션 제거 |
| `get_transactions()` | 블록 빌딩용 트랜잭션 가져오기 |
| 자동 제거 | 풀 크기 초과 시 가장 오래된 트랜잭션 제거 |
| 중복 제거 | 발신자+논스로 중복 제거 |

## 6. 페이로드 빌딩

### 6.1 빌드 인자

```rust
BuildPayloadArgs {
    timestamp: u64,                     // 목표 타임스탬프
    prev_randao: H256,                  // RANDAO 값
    suggested_fee_recipient: Address,   // 수수료 수신자
    withdrawals: Vec<Withdrawal>,       // 출금 목록 (Shanghai)
    parent_block_hash: H256,            // 부모 블록 해시
    parent_blob_gas_used: Option<u64>,  // 블롭 가스 (Cancun)
}
```

### 6.2 빌딩 과정

```
1. 부모 블록과 상태 가져오기
2. 기본 수수료(Base Fee) 계산 (EIP-1559)
3. 초과 블롭 가스 계산 (EIP-4844)
4. 멤풀에서 트랜잭션 선택 (가스 가격순)
5. 트랜잭션 순차 실행
6. 가스, 블룸 필터, 영수증 루트 검증
7. 최종 ExecutionPayload 구성
```

## 7. 동기화 메커니즘

### 7.1 풀 싱크 (Full Sync)

```
제네시스부터 시작
    │
    v
헤더 다운로드 (피어로부터)
    │
    v
블록 바디 다운로드
    │
    v
1024개 블록씩 배치로 실행
    │
    v
각 배치 후 상태 커밋
    │
    v
최신 블록까지 도달 → 동기화 완료
```

### 7.2 스냅 싱크 (Snap Sync)

```
Phase 1: 블록 헤더 다운로드 (피벗 블록 찾기)
    │
Phase 2-3: 계정 다운로드 및 삽입
    │  - 해시 범위별 계정 다운로드
    │  - 계정 트라이에 병렬 삽입
    │
Phase 4-5: 스토리지 다운로드 및 삽입
    │  - 각 계정의 스토리지 슬롯 다운로드
    │  - 스토리지 트라이에 병렬 삽입
    │
Phase 6-7: 상태 및 스토리지 힐링
    │  - 누락된 중간 트라이 노드 다운로드
    │  - 해시 검증으로 트라이 무결성 확보
    │
Phase 8: 바이트코드 다운로드
    │  - 컨트랙트 코드 다운로드
    │  - keccak 해시로 코드 검증
    │
    v
최근 블록 실행으로 최종 동기화
```

## 8. 메시지 기반 액터 모델

L2 컴포넌트들은 메시지 기반 액터 모델로 통신한다:

```
┌─────────────┐     ┌──────────────┐     ┌───────────────┐
│ BlockProducer│     │ L1Committer  │     │ L1Watcher     │
│ (블록 생산)  │     │ (배치 커밋)  │     │ (L1 감시)     │
└──────┬──────┘     └──────┬───────┘     └───────┬───────┘
       │                   │                     │
       │   InMessage       │   InMessage         │  InMessage
       │   ::Produce       │   ::Commit          │  ::WatchLogsL1
       │                   │                     │
       v                   v                     v
┌──────────────────────────────────────────────────────────┐
│              Spawned Concurrency (GenServer)              │
│              (비동기 메시지 전달, 건강 모니터링)           │
└──────────────────────────────────────────────────────────┘
```

각 컴포넌트는 `CallMessage::Health`에 응답하여 구조화된 건강 상태 데이터를 반환한다.

## 9. 기능 게이트 (Feature Gates)

```rust
#[cfg(feature = "l2")]                    // L2 전용 컴포넌트
#[cfg(feature = "c-kzg")]                 // KZG 커밋먼트
#[cfg(feature = "metrics")]               // Prometheus 메트릭
#[cfg(feature = "sp1")]                   // SP1 프루버
#[cfg(feature = "risc0")]                 // RISC Zero 프루버
#[cfg(feature = "zisk")]                  // Zisk 프루버
#[cfg(feature = "openvm")]                // OpenVM 프루버
#[cfg(feature = "gpu")]                   // GPU 가속
#[cfg(feature = "experimental-discv5")]   // DiscV5 노드 디스커버리
```

## 10. 비동기 처리와 취소

- **CancellationToken**: 안전한 종료 신호 전파
- **PayloadBuildTask**: 취소 가능한 비동기 페이로드 빌딩
- **GenServerHandle**: 타입된 메시지 전달 채널
- **Tokio 런타임**: 비동기 I/O 처리
- **Rayon**: CPU 집약적 작업의 병렬 처리
