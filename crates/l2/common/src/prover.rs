use bytes::Bytes;
use ethrex_common::types::{
    Block, blobs_bundle, block_execution_witness::ExecutionWitness, fee_config::FeeConfig,
};
use rkyv::{Archive, Deserialize as RDeserialize, Serialize as RSerialize};
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use std::fmt::{Debug, Display};

use crate::calldata::Value;

#[serde_as]
#[derive(Serialize, Deserialize, RDeserialize, RSerialize, Archive)]
pub struct ProverInputData {
    pub blocks: Vec<Block>,
    pub execution_witness: ExecutionWitness,
    pub elasticity_multiplier: u64,
    #[serde_as(as = "[_; 48]")]
    pub blob_commitment: blobs_bundle::Commitment,
    #[serde_as(as = "[_; 48]")]
    pub blob_proof: blobs_bundle::Proof,
    pub fee_configs: Vec<FeeConfig>,
}

/// Enum used to identify the different proving systems.
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProverType {
    Exec,
    RISC0,
    SP1,
    TDX,
    Tokamak,
}

impl From<ProverType> for u32 {
    fn from(value: ProverType) -> u32 {
        match value {
            ProverType::Exec => 0,
            ProverType::RISC0 => 1,
            ProverType::SP1 => 2,
            ProverType::TDX => 3,
            ProverType::Tokamak => 4,
        }
    }
}

impl ProverType {
    /// Used to iterate through all the possible proving systems
    pub fn all() -> impl Iterator<Item = ProverType> {
        [
            ProverType::Exec,
            ProverType::RISC0,
            ProverType::SP1,
            ProverType::TDX,
            ProverType::Tokamak,
        ]
        .into_iter()
    }

    /// Used to get the empty_calldata structure for that specific prover
    /// It has to match the `OnChainProposer.sol` verify() function
    pub fn empty_calldata(&self) -> Vec<Value> {
        match self {
            ProverType::RISC0 => {
                vec![Value::Bytes(vec![].into())]
            }
            ProverType::SP1 => {
                vec![Value::Bytes(vec![].into())]
            }
            ProverType::TDX => {
                vec![Value::Bytes(vec![].into())]
            }
            ProverType::Tokamak => {
                vec![Value::Bytes(vec![].into())]
            }
            ProverType::Exec => unimplemented!("Doesn't need to generate an empty calldata."),
        }
    }

    /// Used to call a getter for the REQUIRE_*_PROOF boolean in the OnChainProposer contract
    pub fn verifier_getter(&self) -> Option<String> {
        // These values have to match with the OnChainProposer.sol contract
        match self {
            Self::RISC0 => Some("REQUIRE_RISC0_PROOF()".to_string()),
            Self::SP1 => Some("REQUIRE_SP1_PROOF()".to_string()),
            Self::TDX => Some("REQUIRE_TDX_PROOF()".to_string()),
            Self::Tokamak => Some("REQUIRE_TOKAMAK_PROOF()".to_string()),
            Self::Exec => None,
        }
    }
}

impl Display for ProverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Exec => write!(f, "Exec"),
            Self::RISC0 => write!(f, "RISC0"),
            Self::SP1 => write!(f, "SP1"),
            Self::TDX => write!(f, "TDX"),
            Self::Tokamak => write!(f, "Tokamak"),
        }
    }
}

/// Contains the proof data recently created by the prover.
/// It can be either a `ProofCalldata` ready to be sent to the on-chain verifier or a `ProofBytes`
/// to be sent to Aligned.
#[derive(PartialEq, Serialize, Deserialize, Clone, Debug)]
pub enum BatchProof {
    ProofCalldata(ProofCalldata),
    ProofBytes(ProofBytes),
}

impl BatchProof {
    pub fn prover_type(&self) -> ProverType {
        match self {
            BatchProof::ProofCalldata(proof) => proof.prover_type,
            BatchProof::ProofBytes(proof) => proof.prover_type,
        }
    }

    pub fn calldata(&self) -> Vec<Value> {
        match self {
            BatchProof::ProofCalldata(proof) => proof.calldata.clone(),
            BatchProof::ProofBytes(_) => vec![],
        }
    }

    pub fn compressed(&self) -> Option<Vec<u8>> {
        match self {
            BatchProof::ProofCalldata(_) => None,
            BatchProof::ProofBytes(proof) => Some(proof.proof.clone()),
        }
    }

    pub fn public_values(&self) -> Vec<u8> {
        match self {
            BatchProof::ProofCalldata(_) => vec![],
            BatchProof::ProofBytes(proof_bytes) => proof_bytes.public_values.clone(),
        }
    }
}

/// Contains the Proof and the public values generated by the prover.
/// It is used to send the proof to Aligned.
#[derive(PartialEq, Serialize, Deserialize, Clone, Debug)]
pub struct ProofBytes {
    pub prover_type: ProverType,
    pub proof: Vec<u8>,
    pub public_values: Vec<u8>,
}

/// Contains the data ready to be sent to the on-chain verifiers.
#[derive(PartialEq, Serialize, Deserialize, Clone, Debug)]
pub struct ProofCalldata {
    pub prover_type: ProverType,
    pub calldata: Vec<Value>,
}

/// Indicates the prover which proof *format* to generate
#[derive(Serialize, Deserialize, Clone, Copy, Debug, Default)]
pub enum ProofFormat {
    #[default]
    /// A compressed proof wrapped over groth16. EVM friendly.
    Groth16,
    /// Fixed size STARK execution proof.
    Compressed,
}

/// Enum for the ProverServer <--> ProverClient Communication Protocol.
#[allow(clippy::large_enum_variant)]
#[derive(Serialize, Deserialize)]
pub enum ProofData {
    /// 1.
    /// The client performs any needed setup steps
    /// This includes things such as key registration
    ProverSetup {
        prover_type: ProverType,
        payload: Bytes,
    },

    /// 2.
    /// The Server acknowledges the receipt of the setup and it's completion
    ProverSetupACK,

    /// 3.
    /// The Client initiates the connection with a BatchRequest.
    /// Asking for the ProverInputData the prover_server considers/needs.
    /// The commit hash is used to ensure the client and server are compatible.
    /// The prover_type tells the coordinator which backend the client runs,
    /// so it can skip batches that already have a proof for that type.
    /// The optional supported_programs field lists the guest programs the
    /// prover can handle (empty = all / legacy prover).
    BatchRequest {
        commit_hash: String,
        prover_type: ProverType,
        #[serde(default)]
        supported_programs: Vec<String>,
    },

    /// 4.
    /// The Server responds with VersionMismatch when the prover's code version
    /// does not match the version needed to prove the next batch. This can happen
    /// when the batch was stored with a different version, or when the prover is
    /// stale and future batches will use a newer version.
    VersionMismatch,

    /// 4b.
    /// The Server responds with ProverTypeNotNeeded when the connecting prover's
    /// backend type is not in the set of required proof types for this deployment.
    ProverTypeNotNeeded { prover_type: ProverType },

    /// 5.
    /// The Server responds with a BatchResponse containing the ProverInputData.
    /// If the BatchResponse is ProofData::BatchResponse{None, None, None},
    /// the Client knows the BatchRequest couldn't be performed.
    /// The optional program_id tells the prover which guest program to use.
    BatchResponse {
        batch_number: Option<u64>,
        input: Option<ProverInputData>,
        format: Option<ProofFormat>,
        #[serde(default)]
        program_id: Option<String>,
    },

    /// 6.
    /// The Client submits the zk Proof generated by the prover for the specified batch.
    /// The program_id identifies which guest program produced the proof.
    ProofSubmit {
        batch_number: u64,
        batch_proof: BatchProof,
        #[serde(default = "default_program_id")]
        program_id: String,
    },

    /// 7.
    /// The Server acknowledges the receipt of the proof and updates its state,
    ProofSubmitACK { batch_number: u64 },
}

/// Default program id for backward compatibility with pre-modularization provers.
fn default_program_id() -> String {
    "evm-l2".to_string()
}

impl ProofData {
    /// Builder function for creating a ProverSetup
    pub fn prover_setup(prover_type: ProverType, payload: Bytes) -> Self {
        ProofData::ProverSetup {
            prover_type,
            payload,
        }
    }

    /// Builder function for creating a ProverSetupACK
    pub fn prover_setup_ack() -> Self {
        ProofData::ProverSetupACK
    }

    /// Builder function for creating a BatchRequest
    pub fn batch_request(commit_hash: String, prover_type: ProverType) -> Self {
        ProofData::BatchRequest {
            commit_hash,
            prover_type,
            supported_programs: Vec::new(),
        }
    }

    /// Builder function for creating a BatchRequest with supported programs.
    pub fn batch_request_with_programs(
        commit_hash: String,
        prover_type: ProverType,
        supported_programs: Vec<String>,
    ) -> Self {
        ProofData::BatchRequest {
            commit_hash,
            prover_type,
            supported_programs,
        }
    }

    /// Builder function for creating a VersionMismatch
    pub fn version_mismatch() -> Self {
        ProofData::VersionMismatch
    }

    /// Builder function for creating a BatchResponse
    pub fn batch_response(batch_number: u64, input: ProverInputData, format: ProofFormat) -> Self {
        ProofData::BatchResponse {
            batch_number: Some(batch_number),
            input: Some(input),
            format: Some(format),
            program_id: None,
        }
    }

    /// Builder function for creating a BatchResponse with a program id.
    pub fn batch_response_with_program(
        batch_number: u64,
        input: ProverInputData,
        format: ProofFormat,
        program_id: String,
    ) -> Self {
        ProofData::BatchResponse {
            batch_number: Some(batch_number),
            input: Some(input),
            format: Some(format),
            program_id: Some(program_id),
        }
    }

    pub fn empty_batch_response() -> Self {
        ProofData::BatchResponse {
            batch_number: None,
            input: None,
            format: None,
            program_id: None,
        }
    }

    /// Builder function for creating a ProofSubmit
    pub fn proof_submit(batch_number: u64, batch_proof: BatchProof) -> Self {
        ProofData::ProofSubmit {
            batch_number,
            batch_proof,
            program_id: default_program_id(),
        }
    }

    /// Builder function for creating a ProofSubmit with a specific program id.
    pub fn proof_submit_with_program(
        batch_number: u64,
        batch_proof: BatchProof,
        program_id: String,
    ) -> Self {
        ProofData::ProofSubmit {
            batch_number,
            batch_proof,
            program_id,
        }
    }

    /// Builder function for creating a ProofSubmitAck
    pub fn proof_submit_ack(batch_number: u64) -> Self {
        ProofData::ProofSubmitACK { batch_number }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ── Protocol backward compatibility tests ──────────────────────────
    //
    // These tests verify that pre-modularization JSON (without the new
    // `supported_programs` / `program_id` fields) still deserializes
    // correctly via `#[serde(default)]`.

    #[test]
    fn batch_request_without_supported_programs_deserializes() {
        // Old-format prover: no supported_programs field.
        let json = r#"{"BatchRequest":{"commit_hash":"abc123","prover_type":"Exec"}}"#;
        let data: ProofData = serde_json::from_str(json).expect("should deserialize");
        match data {
            ProofData::BatchRequest {
                commit_hash,
                prover_type,
                supported_programs,
            } => {
                assert_eq!(commit_hash, "abc123");
                assert_eq!(prover_type, ProverType::Exec);
                assert!(supported_programs.is_empty(), "default should be empty vec");
            }
            _ => panic!("expected BatchRequest"),
        }
    }

    #[test]
    fn batch_request_with_supported_programs_roundtrips() {
        let original = ProofData::batch_request_with_programs(
            "hash1".to_string(),
            ProverType::SP1,
            vec!["evm-l2".to_string(), "zk-dex".to_string()],
        );
        let json = serde_json::to_string(&original).expect("serialize");
        let deserialized: ProofData = serde_json::from_str(&json).expect("deserialize");
        match deserialized {
            ProofData::BatchRequest {
                commit_hash,
                prover_type,
                supported_programs,
            } => {
                assert_eq!(commit_hash, "hash1");
                assert_eq!(prover_type, ProverType::SP1);
                assert_eq!(supported_programs, vec!["evm-l2", "zk-dex"]);
            }
            _ => panic!("expected BatchRequest"),
        }
    }

    #[test]
    fn batch_response_without_program_id_deserializes() {
        // Old-format coordinator: no program_id field.
        let json =
            r#"{"BatchResponse":{"batch_number":42,"input":null,"format":null}}"#;
        let data: ProofData = serde_json::from_str(json).expect("should deserialize");
        match data {
            ProofData::BatchResponse {
                batch_number,
                program_id,
                ..
            } => {
                assert_eq!(batch_number, Some(42));
                assert!(program_id.is_none(), "default should be None");
            }
            _ => panic!("expected BatchResponse"),
        }
    }

    #[test]
    fn batch_response_with_program_id_roundtrips() {
        let json = r#"{"BatchResponse":{"batch_number":7,"input":null,"format":null,"program_id":"zk-dex"}}"#;
        let data: ProofData = serde_json::from_str(json).expect("should deserialize");
        match data {
            ProofData::BatchResponse { program_id, .. } => {
                assert_eq!(program_id, Some("zk-dex".to_string()));
            }
            _ => panic!("expected BatchResponse"),
        }
    }

    #[test]
    fn proof_submit_without_program_id_uses_default() {
        // Old-format prover: no program_id field in ProofSubmit.
        let json = r#"{
            "ProofSubmit": {
                "batch_number": 1,
                "batch_proof": {
                    "ProofCalldata": {
                        "prover_type": "Exec",
                        "calldata": []
                    }
                }
            }
        }"#;
        let data: ProofData = serde_json::from_str(json).expect("should deserialize");
        match data {
            ProofData::ProofSubmit { program_id, .. } => {
                assert_eq!(program_id, "evm-l2", "default program_id should be evm-l2");
            }
            _ => panic!("expected ProofSubmit"),
        }
    }

    #[test]
    fn proof_submit_with_program_id_roundtrips() {
        let proof = BatchProof::ProofCalldata(ProofCalldata {
            prover_type: ProverType::Exec,
            calldata: vec![],
        });
        let original =
            ProofData::proof_submit_with_program(5, proof, "tokamon".to_string());
        let json = serde_json::to_string(&original).expect("serialize");
        let deserialized: ProofData = serde_json::from_str(&json).expect("deserialize");
        match deserialized {
            ProofData::ProofSubmit {
                batch_number,
                program_id,
                ..
            } => {
                assert_eq!(batch_number, 5);
                assert_eq!(program_id, "tokamon");
            }
            _ => panic!("expected ProofSubmit"),
        }
    }

    #[test]
    fn empty_supported_programs_roundtrip() {
        let original = ProofData::batch_request_with_programs(
            "hash".to_string(),
            ProverType::Exec,
            vec![],
        );
        let json = serde_json::to_string(&original).expect("serialize");
        let deserialized: ProofData = serde_json::from_str(&json).expect("deserialize");
        match deserialized {
            ProofData::BatchRequest {
                supported_programs, ..
            } => {
                assert!(supported_programs.is_empty());
            }
            _ => panic!("expected BatchRequest"),
        }
    }

    #[test]
    fn default_program_id_is_evm_l2() {
        assert_eq!(default_program_id(), "evm-l2");
    }

    #[test]
    fn all_variants_roundtrip() {
        // Verify every ProofData variant can serialize/deserialize.
        let proof = BatchProof::ProofCalldata(ProofCalldata {
            prover_type: ProverType::Exec,
            calldata: vec![],
        });
        let variants: Vec<ProofData> = vec![
            ProofData::prover_setup(ProverType::SP1, bytes::Bytes::from_static(b"key")),
            ProofData::prover_setup_ack(),
            ProofData::batch_request("h".into(), ProverType::RISC0),
            ProofData::batch_request_with_programs(
                "h".into(),
                ProverType::SP1,
                vec!["evm-l2".into()],
            ),
            ProofData::version_mismatch(),
            ProofData::empty_batch_response(),
            ProofData::proof_submit(1, proof.clone()),
            ProofData::proof_submit_with_program(2, proof, "zk-dex".into()),
            ProofData::proof_submit_ack(3),
            ProofData::ProverTypeNotNeeded {
                prover_type: ProverType::TDX,
            },
        ];
        for variant in &variants {
            let json = serde_json::to_string(variant).expect("serialize");
            let _: ProofData = serde_json::from_str(&json).expect("deserialize");
        }
    }

    #[test]
    fn extra_json_fields_ignored() {
        // Verify that extra unknown fields in JSON don't break deserialization.
        let json = r#"{"BatchRequest":{"commit_hash":"abc","prover_type":"Exec","supported_programs":[],"unknown_field":"value"}}"#;
        let data: ProofData = serde_json::from_str(json).expect("should ignore extra fields");
        match data {
            ProofData::BatchRequest { commit_hash, .. } => {
                assert_eq!(commit_hash, "abc");
            }
            _ => panic!("expected BatchRequest"),
        }
    }

    #[test]
    fn empty_batch_response_roundtrips() {
        let original = ProofData::empty_batch_response();
        let json = serde_json::to_string(&original).expect("serialize");
        let deserialized: ProofData = serde_json::from_str(&json).expect("deserialize");
        match deserialized {
            ProofData::BatchResponse {
                batch_number,
                input,
                format,
                program_id,
            } => {
                assert!(batch_number.is_none());
                assert!(input.is_none());
                assert!(format.is_none());
                assert!(program_id.is_none());
            }
            _ => panic!("expected BatchResponse"),
        }
    }
}
