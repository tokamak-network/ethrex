#![no_main]

//! Differential fuzzing: JIT-compiled execution vs LEVM interpreter.
//!
//! This target generates random EVM bytecode, executes it on both the
//! LEVM interpreter and (when the `revmc-backend` feature is enabled)
//! the JIT-compiled path, then compares execution results.
//!
//! Without `revmc-backend`, the target falls back to verifying that the
//! interpreter produces deterministic results across two independent runs.

use bytes::Bytes;
use ethrex_common::constants::EMPTY_TRIE_HASH;
use ethrex_common::types::{Account, BlockHeader, Code, EIP1559Transaction, Transaction, TxKind};
use ethrex_common::{Address, U256};
use ethrex_levm::db::gen_db::GeneralizedDatabase;
use ethrex_levm::environment::Environment;
use ethrex_levm::tracing::LevmCallTracer;
use ethrex_levm::vm::{VMType, VM};
use libfuzzer_sys::fuzz_target;
use rustc_hash::FxHashMap;
use std::sync::Arc;

// ─── Constants ────────────────────────────────────────────────────────────────

/// Standard contract address used across fuzz runs.
const CONTRACT_ADDR: u64 = 0x42;

/// Standard sender address used across fuzz runs.
const SENDER_ADDR: u64 = 0x100;

/// Intrinsic gas for a basic EIP-1559 CALL transaction.
#[cfg(feature = "revmc-backend")]
const INTRINSIC_GAS: u64 = 21_000;

/// Gas limit high enough for most fuzz-generated bytecodes.
/// Must not exceed i64::MAX since `CallFrame::gas_remaining` is i64.
#[allow(clippy::as_conversions)]
const FUZZ_GAS_LIMIT: u64 = (i64::MAX - 1) as u64;

/// Maximum bytecode size we test. Anything larger is skipped to keep
/// fuzz iteration speed reasonable. Real EIP-3860 limit is 24576.
const MAX_BYTECODE_LEN: usize = 4096;

// ─── EVM opcodes for bytecode generation ─────────────────────────────────────

/// Simple arithmetic/logic opcodes that only manipulate the stack.
const STACK_OPCODES: &[u8] = &[
    0x01, // ADD
    0x02, // MUL
    0x03, // SUB
    0x04, // DIV
    0x05, // SDIV
    0x06, // MOD
    0x07, // SMOD
    0x08, // ADDMOD
    0x09, // MULMOD
    0x0A, // EXP
    0x0B, // SIGNEXTEND
    0x10, // LT
    0x11, // GT
    0x12, // SLT
    0x13, // SGT
    0x14, // EQ
    0x15, // ISZERO
    0x16, // AND
    0x17, // OR
    0x18, // XOR
    0x19, // NOT
    0x1A, // BYTE
    0x1B, // SHL
    0x1C, // SHR
    0x1D, // SAR
    0x50, // POP
];

/// Opcodes that read execution context (push one value onto the stack).
const CONTEXT_OPCODES: &[u8] = &[
    0x30, // ADDRESS
    0x32, // ORIGIN
    0x33, // CALLER
    0x34, // CALLVALUE
    0x36, // CALLDATASIZE
    0x38, // CODESIZE
    0x3A, // GASPRICE
    0x41, // COINBASE
    0x42, // TIMESTAMP
    0x43, // NUMBER
    0x44, // DIFFICULTY / PREVRANDAO
    0x45, // GASLIMIT
    0x46, // CHAINID
    0x48, // BASEFEE
    0x58, // PC
    0x59, // MSIZE
    0x5A, // GAS
];

/// Memory opcodes.
const MEMORY_OPCODES: &[u8] = &[
    0x51, // MLOAD
    0x52, // MSTORE
    0x53, // MSTORE8
];

/// DUP1-DUP16 (0x80-0x8F).
const DUP_BASE: u8 = 0x80;

/// SWAP1-SWAP16 (0x90-0x9F).
const SWAP_BASE: u8 = 0x90;

// ─── Bytecode generation from fuzz data ──────────────────────────────────────

/// Generate a valid EVM bytecode sequence from raw fuzz data.
///
/// Strategy: consume fuzz bytes one at a time as "opcode selectors".
/// Each selector byte picks an opcode category and specific opcode.
/// PUSH instructions consume additional fuzz bytes as immediate data.
/// The sequence always ends with STOP (0x00) for clean termination.
fn generate_bytecode(data: &[u8]) -> Vec<u8> {
    let mut bytecode = Vec::with_capacity(data.len() * 2);
    let mut i = 0;

    while i < data.len() && bytecode.len() < MAX_BYTECODE_LEN {
        let selector = data[i];
        i += 1;

        match selector % 8 {
            // 0: PUSH1-PUSH32 — consume N additional bytes as immediate data.
            0 => {
                if i >= data.len() {
                    break;
                }
                // Determine PUSH width (1-32), biased toward small pushes.
                let push_width = ((data.get(i).copied().unwrap_or(0) % 32) + 1) as usize;
                i += 1;
                let opcode = 0x5F + push_width as u8; // PUSH1=0x60, PUSH32=0x7F
                bytecode.push(opcode);

                // Fill immediate bytes from fuzz data (or zero-pad).
                for j in 0..push_width {
                    bytecode.push(data.get(i + j).copied().unwrap_or(0));
                }
                i += push_width;
            }

            // 1: Stack arithmetic/logic opcodes.
            1 => {
                let idx = selector as usize / 8 % STACK_OPCODES.len();
                bytecode.push(STACK_OPCODES[idx]);
            }

            // 2: Context-reading opcodes (push env values).
            2 => {
                let idx = selector as usize / 8 % CONTEXT_OPCODES.len();
                bytecode.push(CONTEXT_OPCODES[idx]);
            }

            // 3: DUP1-DUP16.
            3 => {
                let n = selector / 8 % 16;
                bytecode.push(DUP_BASE + n);
            }

            // 4: SWAP1-SWAP16.
            4 => {
                let n = selector / 8 % 16;
                bytecode.push(SWAP_BASE + n);
            }

            // 5: Memory operations (with a small PUSH for the offset first).
            5 => {
                let idx = selector as usize / 8 % MEMORY_OPCODES.len();
                // Push a small memory offset to avoid huge memory expansion.
                bytecode.push(0x60); // PUSH1
                bytecode.push(data.get(i).copied().unwrap_or(0) & 0x7F); // offset 0-127
                i += 1;
                // Push a value for MSTORE/MSTORE8.
                if MEMORY_OPCODES[idx] == 0x52 || MEMORY_OPCODES[idx] == 0x53 {
                    bytecode.push(0x60); // PUSH1
                    bytecode.push(data.get(i).copied().unwrap_or(0x42));
                    i += 1;
                    // Swap so offset is on top for MSTORE (value, offset -> MSTORE).
                    // MSTORE expects (offset, value) with offset on top.
                    bytecode.push(0x90); // SWAP1
                }
                bytecode.push(MEMORY_OPCODES[idx]);
            }

            // 6: PUSH1 with small constant (stack building).
            6 => {
                bytecode.push(0x60); // PUSH1
                bytecode.push(selector);
            }

            // 7: STOP / RETURN / REVERT (early termination).
            7 => {
                match selector / 8 % 4 {
                    0 => bytecode.push(0x00), // STOP
                    1 => {
                        // RETURN(0, 0) — return empty.
                        bytecode.push(0x60);
                        bytecode.push(0x00); // size = 0
                        bytecode.push(0x60);
                        bytecode.push(0x00); // offset = 0
                        bytecode.push(0xF3); // RETURN
                    }
                    2 => {
                        // REVERT(0, 0) — revert empty.
                        bytecode.push(0x60);
                        bytecode.push(0x00); // size = 0
                        bytecode.push(0x60);
                        bytecode.push(0x00); // offset = 0
                        bytecode.push(0xFD); // REVERT
                    }
                    _ => bytecode.push(0x00), // STOP
                }
                // After a termination opcode, stop generating.
                break;
            }

            _ => unreachable!(),
        }
    }

    // Always terminate with STOP if we didn't already.
    if bytecode.last().copied() != Some(0x00)
        && bytecode.last().copied() != Some(0xF3)
        && bytecode.last().copied() != Some(0xFD)
    {
        bytecode.push(0x00); // STOP
    }

    bytecode
}

// ─── Database setup ──────────────────────────────────────────────────────────

/// Create an in-memory `GeneralizedDatabase` with pre-seeded contract and sender accounts.
///
/// Mirrors the pattern from `test_helpers::make_test_db` but uses direct path
/// dependencies available to the standalone fuzz crate.
fn make_fuzz_db(code: Code) -> GeneralizedDatabase {
    let contract_addr = Address::from_low_u64_be(CONTRACT_ADDR);
    let sender_addr = Address::from_low_u64_be(SENDER_ADDR);

    let store = ethrex_storage::Store::new("", ethrex_storage::EngineType::InMemory)
        .expect("in-memory store creation must succeed");
    let header = BlockHeader {
        state_root: *EMPTY_TRIE_HASH,
        ..Default::default()
    };
    let vm_db: ethrex_vm::DynVmDatabase = Box::new(
        ethrex_blockchain::vm::StoreVmDatabase::new(store, header)
            .expect("StoreVmDatabase creation must succeed"),
    );

    let mut accounts = FxHashMap::default();
    accounts.insert(
        contract_addr,
        Account::new(U256::MAX, code, 0, FxHashMap::default()),
    );
    accounts.insert(
        sender_addr,
        Account::new(
            U256::MAX,
            Code::from_bytecode(Bytes::new()),
            0,
            FxHashMap::default(),
        ),
    );

    GeneralizedDatabase::new_with_account_state(Arc::new(vm_db), accounts)
}

/// Create a standard test environment for fuzz execution.
fn make_fuzz_env(sender: Address) -> Environment {
    Environment {
        origin: sender,
        gas_limit: FUZZ_GAS_LIMIT,
        block_gas_limit: FUZZ_GAS_LIMIT,
        ..Default::default()
    }
}

/// Create a standard EIP-1559 transaction calling the contract.
fn make_fuzz_tx(contract: Address, calldata: Bytes) -> Transaction {
    Transaction::EIP1559Transaction(EIP1559Transaction {
        to: TxKind::Call(contract),
        data: calldata,
        ..Default::default()
    })
}

// ─── Interpreter execution ───────────────────────────────────────────────────

/// Result of a single execution path.
struct ExecResult {
    success: bool,
    gas_used: u64,
    gas_refunded: u64,
    output: Bytes,
}

/// Execute bytecode through the LEVM interpreter via `VM::stateless_execute`.
fn run_interpreter(code: Code) -> Option<ExecResult> {
    let contract_addr = Address::from_low_u64_be(CONTRACT_ADDR);
    let sender_addr = Address::from_low_u64_be(SENDER_ADDR);

    let mut db = make_fuzz_db(code);
    let env = make_fuzz_env(sender_addr);
    let tx = make_fuzz_tx(contract_addr, Bytes::new());

    let mut vm = VM::new(
        env,
        &mut db,
        &tx,
        LevmCallTracer::disabled(),
        VMType::L1,
    )
    .ok()?;

    let report = vm.stateless_execute().ok()?;

    Some(ExecResult {
        success: report.is_success(),
        gas_used: report.gas_used,
        gas_refunded: report.gas_refunded,
        output: report.output,
    })
}

// ─── JIT execution (revmc-backend) ──────────────────────────────────────────

/// Execute bytecode through the JIT-compiled path.
///
/// This function is only available when the `revmc-backend` feature is enabled.
/// It compiles the bytecode via revmc/LLVM, then executes via `execute_jit`.
#[cfg(feature = "revmc-backend")]
fn run_jit(code: Code) -> Option<JitExecResult> {
    use ethrex_levm::call_frame::{CallFrame, Stack};
    use ethrex_levm::jit::cache::CodeCache;
    use ethrex_levm::jit::types::JitOutcome;
    use ethrex_levm::memory::Memory;
    use ethrex_levm::vm::{JIT_STATE, Substate};
    use tokamak_jit::backend::RevmcBackend;
    use tokamak_jit::execution::execute_jit;

    let contract_addr = Address::from_low_u64_be(CONTRACT_ADDR);
    let sender_addr = Address::from_low_u64_be(SENDER_ADDR);

    JIT_STATE.reset_for_testing();

    let fork = ethrex_common::types::Fork::Cancun;

    // Compile via revmc.
    let backend = RevmcBackend::default();
    let code_cache = CodeCache::new();
    backend.compile_and_cache(&code, fork, &code_cache).ok()?;

    let compiled = code_cache.get(&(code.hash, fork))?;

    // Set up JIT execution state.
    let mut db = make_fuzz_db(code.clone());
    let env = make_fuzz_env(sender_addr);

    let mut call_frame = CallFrame::new(
        sender_addr,
        contract_addr,
        contract_addr,
        code,
        U256::zero(),
        Bytes::new(),
        false,
        FUZZ_GAS_LIMIT,
        0,
        false,
        false,
        0,
        0,
        Stack::default(),
        Memory::default(),
    );

    let mut substate = Substate::default();
    let mut storage_original_values = FxHashMap::default();

    let outcome = execute_jit(
        &compiled,
        &mut call_frame,
        &mut db,
        &mut substate,
        &env,
        &mut storage_original_values,
    )
    .ok()?;

    match outcome {
        JitOutcome::Success { gas_used, output } => Some(JitExecResult {
            success: true,
            gas_used,
            output,
        }),
        JitOutcome::Revert { gas_used, output } => Some(JitExecResult {
            success: false,
            gas_used,
            output,
        }),
        // Suspended (CALL/CREATE) or Error — we skip these for differential
        // comparison since our bytecodes don't generate external calls.
        JitOutcome::Suspended { .. } | JitOutcome::Error(_) => None,
    }
}

/// JIT execution result with gas metrics.
#[cfg(feature = "revmc-backend")]
struct JitExecResult {
    success: bool,
    gas_used: u64,
    output: Bytes,
}

// ─── Differential comparison ─────────────────────────────────────────────────

/// Compare JIT and interpreter results.
///
/// Validates:
/// 1. Success/revert status must match.
/// 2. Pre-refund gas must match (interpreter_gas_used + interpreter_refunded == jit_gas_used + INTRINSIC_GAS).
/// 3. Return data must match.
#[cfg(feature = "revmc-backend")]
fn compare_results(interp: &ExecResult, jit: &JitExecResult, bytecode: &[u8]) {
    // 1. Execution status must match.
    assert_eq!(
        interp.success, jit.success,
        "Status mismatch: interp={}, jit={}, bytecode={:02x?}",
        interp.success, jit.success, bytecode
    );

    // 2. Pre-refund gas alignment.
    //
    // The interpreter's `gas_used` is post-refund for Cancun. We reconstruct
    // pre-refund: interp_pre_refund = gas_used + gas_refunded.
    // JIT's `gas_used` is pre-refund (execution gas only, no intrinsic).
    // So: interp_pre_refund == jit_gas_used + INTRINSIC_GAS.
    let interp_pre_refund = interp.gas_used.saturating_add(interp.gas_refunded);
    let jit_total = jit.gas_used.saturating_add(INTRINSIC_GAS);

    assert_eq!(
        interp_pre_refund, jit_total,
        "Pre-refund gas mismatch: interp_pre_refund={} (used={} + refunded={}), \
         jit_total={} (exec={} + intrinsic={}), bytecode={:02x?}",
        interp_pre_refund,
        interp.gas_used,
        interp.gas_refunded,
        jit_total,
        jit.gas_used,
        INTRINSIC_GAS,
        bytecode
    );

    // 3. Return data must match.
    assert_eq!(
        interp.output, jit.output,
        "Output mismatch: interp={:02x?}, jit={:02x?}, bytecode={:02x?}",
        interp.output, jit.output, bytecode
    );
}

// ─── Interpreter-only determinism check ──────────────────────────────────────

/// When JIT is not available, verify the interpreter is deterministic:
/// running the same bytecode twice must produce identical results.
#[cfg(not(feature = "revmc-backend"))]
fn check_interpreter_determinism(bytecode: &[u8]) {
    let code = Code::from_bytecode(Bytes::from(bytecode.to_vec()));

    let result1 = run_interpreter(code.clone());
    let result2 = run_interpreter(code);

    match (result1, result2) {
        (Some(r1), Some(r2)) => {
            assert_eq!(
                r1.success, r2.success,
                "Determinism failure: success mismatch on bytecode={:02x?}",
                bytecode
            );
            assert_eq!(
                r1.gas_used, r2.gas_used,
                "Determinism failure: gas_used mismatch on bytecode={:02x?}",
                bytecode
            );
            assert_eq!(
                r1.gas_refunded, r2.gas_refunded,
                "Determinism failure: gas_refunded mismatch on bytecode={:02x?}",
                bytecode
            );
            assert_eq!(
                r1.output, r2.output,
                "Determinism failure: output mismatch on bytecode={:02x?}",
                bytecode
            );
        }
        (None, None) => {
            // Both failed identically — OK.
        }
        (r1, r2) => {
            panic!(
                "Determinism failure: one run produced a result, the other did not. \
                 run1={}, run2={}, bytecode={:02x?}",
                r1.is_some(),
                r2.is_some(),
                bytecode
            );
        }
    }
}

// ─── Fuzz target ─────────────────────────────────────────────────────────────

fuzz_target!(|data: &[u8]| {
    // Skip very short inputs that can't produce meaningful bytecode.
    if data.len() < 4 {
        return;
    }

    let bytecode = generate_bytecode(data);

    // Skip empty generated bytecodes.
    if bytecode.is_empty() {
        return;
    }

    // With revmc-backend: real differential JIT vs interpreter comparison.
    #[cfg(feature = "revmc-backend")]
    {
        let code = Code::from_bytecode(Bytes::from(bytecode.clone()));
        let interp_result = run_interpreter(code.clone());
        let jit_result = run_jit(code);

        match (interp_result, jit_result) {
            (Some(interp), Some(jit)) => {
                compare_results(&interp, &jit, &bytecode);
            }
            (Some(_), None) => {
                // JIT compilation failed but interpreter succeeded.
                // This is acceptable — JIT may reject certain bytecode patterns
                // (e.g., oversized, empty after analysis).
            }
            (None, Some(jit)) => {
                // Interpreter failed but JIT succeeded — suspicious.
                // Log for visibility during fuzz campaigns.
                eprintln!(
                    "WARNING: interpreter=None but jit=Some(success={}), bytecode={:02x?}",
                    jit.success, &bytecode[..bytecode.len().min(64)]
                );
            }
            (None, None) => {
                // Both failed — OK.
            }
        }
    }

    // Without revmc-backend: verify interpreter determinism.
    #[cfg(not(feature = "revmc-backend"))]
    {
        check_interpreter_determinism(&bytecode);
    }
});
